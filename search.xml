<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《软件工程导论》第一章]]></title>
    <url>%2F2021%2F03%2F05%2Fruan-jian-gong-cheng-dao-lun-di-yi-zhang%2F</url>
    <content type="text"><![CDATA[一、软件工程学概述1.1软件危机1、为了更有效地开发与维护软件，软件工作者在==20世纪60年代后期==开始认真研究消除软件危机的途径，从而逐渐形成了一门新兴的==工程学科==——计算机软件工程学（通常简称为“软件工程”）2、==1968年北大西洋公约组织==的计算机科学家在西德召开国际会议，讨论软件危机问题，在这次会议正式提出并使用了“软件工程”这个名词，一门新兴的工程学科就此诞生了。3、==软件危机的定义：== 软件危机是指在计算机的开发和维护过程中所遇到的一系列严重问题。4、概括地说，软件危机包含下述两方面问题： 如何开发软件，以满足社会对软件日益增长的需求。 如何更有效地维护数量不断膨胀的已有软件。 ==5、== 软件危机的典型表现： 对软件开发成本和进度的估计常常很不准确； 用户对“已完成的”软件系统不满意的现象经常发生； 软件产品的质量往往靠不住； 软件常常是不可维护的； 软件通常没有适当的文档资料； 软件成本在计算机系统总成本中所占比例逐年上升； 软件开发生产率提高的速度，远远跟不上计算机应用迅速普及深入的趋势。 ==6、== 产生软件危机的原因： 客观原因1.软件不同于硬件，它是计算机系统中的逻辑部分而非物理部分；2.软件较难维护；3.软件不同于一般程序，它的一个显著特点是规模庞大，而且程序复杂性将随着程序规模增加而呈指数上升。 主观原因1.忽视软件需求分析的重要性；2.错误的认为软件开发就是写程序；3.轻视软件维护； 7、详细设计是决定编码质量的关键；做好软件定义时期的工作，是降低软件成本提高软件质量的关键；编写程序所需的工作量只占软件开发全部工作量的10%-20%；测试占40%-50%；实际上用于软件维护的费用占软件总费用的55%-70%；软件工程学的一个重要目标就是提高软件的可维护性，减少软件维护的代价。==8、== 消除软件危机的途径： 首先应该对计算机软件有一个正确的认识，软件是程序、数据及相关文档的完整集合； 必须充分吸取和借鉴前人行之有效的原理、概念、技术和方法； 推广使用在实践中成功的技术和方法； 开发和使用更好的软件工具； 既要有技术措施（方法和工具），又要有必要的组织管理措施。软件工程正是从管理和技术两方面研究如何更好地开发和维护计算机软件的一门新兴学科。 1.2软件工程1、软件工程是指导计算机软件开发和维护的一门工程学科，该学科的目的是生产出能按期交付的、在预算范围内的、满足用户需求的、质量合格的软件产品。2、软件工程的本质特性： 软件工程关注于大型程序的构造； 软件工程的中心课题是控制复杂性； 软件经常变化； 开发软件的效率非常重要； 和谐地合作是开发软件的关键； 软件必须有效地支持它的用户； 在软件工程领域中通常由具有一种文化背景的人替具有另一种文化背景的人创造产品。 ==3、== 软件工程的基本原理： 用分阶段的生命周期计划严格管理； 坚持进行阶段评审； 实行严格的产品控制； 采用现代程序设计技术； 结果应能清楚地审查； 开发小组的人员应该少而精； 承认不断改进软件工程实践的必要性。 8、通常把在软件生命周期全过程中使用的一整套技术方法的集合称为方法学，也称为泛型。9、软件工程方法学包含3个要素：方法、工具 和 过程。10、传统方法学也称为生命周期方法学或结构化范型，其特点是： 采用结构化技术完成软件开发的各项任务。 把软件生命周期划分成若干个阶段，如何顺序地完成每个阶段的任务。 每一个阶段的开始和结束都有严格的标准，对于任何两个相邻的阶段而言，前一阶段的结束标准就是后一个阶段的开始标准。 在每一个阶段结束之前都必须正式严格的技术审查和管理复审。 11、传统方法学的优点： 把软件生命周期划分成若干个阶段，每个阶段的任务相对独立，而且比较简单，便于不同人员协作。 使软件开发工程的全过程以一种有条不紊的方式进行，保证了软件的质量。特别是提高了软件的可维护性。 采用生命周期方法学可以大大提高软件开发的成功率，软件开发的生产率也能明显提高。 12、传统方法学的缺点： 当软件规模庞大，或者对软件的需求是模糊的或会随时间变化而变化的时候，使用传统方法学开发软件往往不成功。 13、面向对象方法学&emsp;&emsp;面向对象方法把数据和行为看成是同等重要的，它是一种以数据为主线，把数据和对数据的操作紧密地结合起来的方法。 把对象作为融合了数据及在数据上的操作行为的统一的软件构件。 把所有对象都划分成类。 按照父类与子类的关系，把若干给相关类组成一个层次结构的系统。 对象彼此间仅能通过发送消息互相联系。 优点： 降低了软件产品的复杂性，提高了软件的可理解性，简化了软件的开发和维护工作，促进了软件重用。 1.3软件生命周期1、软件生命周期由软件定义、软件开发和运行维护（也称软件维护）3个时期组成，每个时期又进一步划分成若干个阶段。2、一个软件从定义、开发、使用和维护，直到最终被废弃，要经历一个漫长的时期，通常把软件经历的这个漫长的时期称为生命周期。3、软件定义时期的任务是：确定软件开发工程必须完成的总目标（问题定义）；确定工程的可行性（可行性分析）；导出实现工程目标应该采用的策略及系统必须完成的功能（需求分析）；估计完成该项工程需要的资源和成本，并且制定工程进度表。软件定义时期通常进一步划分成3个阶段，即==问题定义==、==可行性分析==和==需求分析==。4、开发时期具体设计和实现在前一个时期定义的软件，它通常由下述4个阶段组成：==总体设计==、==详细设计==、==编码==和==单元测试==，==综合测试==。其中前两个阶段又称为系统设计，后两个阶段又称为系统实现。5、维护时期的主要任务是使软件持久地满足用户的需求，每一次维护活动本质都是一次压缩和简化了的定义和开发过程。6、下面简要介绍软件生命周期每个阶段的基本任务。 问题定义：“要解决的问题是什么？” 可行性研究：“对于上一阶段所确定的问题有行得通的解决办法吗？”进行一次大大压缩和简化了的系统分析和设计过程，也就是在较抽象的高层次上进行的分析和设计过程。可行性研究应该比较简短，这个阶段的任务不是具体解决问题，而是研究问题的范围，探索这个问题是否值得去解，是否有可行的解决方案。（可行性研究报告） 需求分析：“为了解决这个问题，目标系统必须做什么”，主要是确定目标系统必须具备哪些功能。通常用数据流图、数据字典和简要的算法表示系统的逻辑模型。（需求规格说明书） 总体设计：“概括地说，应该怎样实现目标系统？”总体设计又称概要设计。软件设计的一条基本原理就是，程序应该模块化，也就是说，一个程序应该由若干个规模适中的模块按合理的层次结构组织而成。因此，总体设计的另一项主要任务就是设计程序的体系结构，也就是确定程序由哪些模块组成以及模块间的关系。（总体设计说明书） 详细设计：“应该怎样具体地实现这个系统呢？”也称为模块设计，详细的设计每个模块，确定实现模块功能所需要的算法和数据结构。（详细设计说明书） 编码和单元测试：这个阶段的关键任务是写出正确的容易理解、容易维护的程序模块。（程序清单和单元测试报告） 综合测试：关键任务是通过各种类型的测试（及相应的调试）使软件达到预定的要求。最基本的测试是集成测试和验收测试。把测试计划则是按照规格说明书的规定（通常在需求分析阶段确定），由用户（或在用户积极参加下）对目标系统进行验收。 软件维护：关键任务是通过各种必要的维护活动使系统持久地满足用户的需要。4类维护活动：改正性维护、适应性维护、完善性维护、预防性维护。 1.4软件过程1、定义：软件过程是为了获得高质量软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤。2、系统是相互关联或相互作用的一组要素。3、过程定义了运用方法的顺序、应该交付的文档资源，为保证软件质量和协调变化所需求采取的管理措施以及标志软件开发各个阶段任务完成的里程碑。4、生命周期模型规定了把生命周期划分成哪些阶段及各个阶段的执行顺序，因此，也成为过程模型。瀑布模型与快速原型模型的主要区别是获取用户需求的方法不同。5、各大模型的特点、优点及缺点、应用范围：==瀑布模型：== 传统软件工程方法学的软件过程，基本上可以用瀑布模型来描述。特点： 阶段间具有顺序性和依赖性。 推迟实现的观点。 质量保证的观点。 优点： 强迫开发人员采用规范的技术方法。 严格地规定了每个阶段必须提交的文档。 每个阶段前必须正式进行严格的技术审查和管理复查。 受文档约束，使软件维护容易一些，瀑布模型的成功在很大程度上是由于它基本上是一种文档驱动的模型。 缺点： 在可运行的软件产品交付给用户之前，用户只能通过文档来了解未来的产品是什么样的。 开发人员和用户之间缺乏有效的沟通，很可能导致最终开发出的软件产品不能真正满足用户的需求。 应用范围： 在开发过程中需求无或很少变化。 分析设计人员对应用领域很熟悉。 低风险项目。 用户使用环境很稳定。 开发工作对用户参与要求低。 ==快速原型模型：== 第一步是快速建立一个反映用户主要需求的原型系统，让用户在计算机上试用它，通过实践来了解目标系统的概貌。优点： 通常能满足用户的真实需求。 软件产品的开发过程基本上是线性顺序过程。 开发人员通过建立原型系统已经学到了许多东西。 缩短了开发周期，加快了进程，降低成本。 缺点： 快速建立的系统结构和连续修改，可能导致产品质量低下。 应用范围： 适用于那些不能预先确切定义需求的软件系统的开发。 适用于那些项目组成员不能很好的交流或者通信的情况下。 注： 软件产品一旦交付给用户使用之后，维护便开始了。&emsp;&emsp; 快速原型的本质是“快速”。 ==增量模型：== 瀑布模型的改进，增量模型也称为渐增模型。使用增量模型时，第一个增量构件往往实现软件的基本需求，提供最核心的功能。当把新构件集成导现有软件中时，所形成的产品必须是可测试的。优点： 能在较短时间内向用户提交可完成部分工作的产品。 人员分配灵活，刚开始不用投入大量人力资源。 逐步增加产品功能，从而使用户有效充裕的时间和适应新产品，减少一个全新软件给用户带来的冲击。 缺点： 在把每个新的增量构件集成到现有软件体系结构中时，必须不破坏原来已经开发出的产品。 从某种意义上说，增量模型本身是自相矛盾的。它一方面要求开发人员把软件看作一个整体，另一方面又要求开发人员把软件看作构件序列，每个构件本质上都独立于另外一个构件。除非开发人员有足够的技术能力协调好这一明显的矛盾，否则用增量模型开发出的产品可能并不令人满意。 使用这种方法将冒构件无法集成到一起的风险，除非密切地监控整个开发过程，否则整个开发过程，否则整个工程可能毁于一旦。 应用范围： 进行已有产品升级或新版本开发，增量模型是非常适合的。 对完成期限严格要求的产品，可以使用增量模型。 对所开发的领域比较熟悉而且已有原型系统，增量模型也是非常适合的。 ==螺旋模型：== 快速原型和瀑布模型的结合。基本思想是使用原型及其他方法来尽量降低风险。理解这种模型的一个简便方法，是它看作在每个阶段之前都增加了风险分析过程的快速原型模型。优点： 有利于已有软件的重用。 有助于把软件质量作为软件开发的一个重要目标。 减少了过多测试或测试不足所带来的风险。 软件维护与软件开发没有本质区别。 缺点： 需要软件开发人员具有丰富的风险评估经验和这方面的专门知识，否则将出现真正的风险。 应用范围： 主要适用于内部开发的大规模软件项目。 注： 小规模用瀑布模型。==喷泉模型：== “喷泉”这个词体现了面向对象软件开发过程迭代和无缝的特性。 适用于面向对象的软件开发。==统一过程模型：==是基于统一建模语言(UML)的面向对象软件开发过程模型。==附：== 思考题以及个人答案：1、软件是什么？&emsp;&emsp;软件是计算机程序、所用的数据及有关文档的集合。可以说：软件=程序+数据+文档。2、为什么说软件是创意产品?&emsp;&emsp;软件具有知识性的特点，其表现在创意为王、知识产品、无磨损、开发投入大复制零成本、传播速度快。3、软件工程中有哪些角色？&emsp;&emsp;项目经理、产品经理、分析设计师、程序员、测评师、实施、维护、培训师、销售等。4、软件的特点都有哪些表现？&emsp;&emsp;软件的特点：知识性、社会性、复杂性、不可见性、硬件性、规模越来越大这些特点可能使软件在开发、使用和维护中留下隐患，导致软件危机。 软件的知识性表现在创意为王、知识产品、无磨损、开发投入大复制零成本、传播速度快。 软件的社会性表现在由人开发、为人所用、人的社会性带入软件、不同人的思想行为影响软件。 软件的复杂性表现在需求越来越复杂、解决方案越来越复杂、工具越来越复杂、质量控制越来越难。 软件的不可见性表现在没有运行时看不见摸不着、运行时内部处理不可见、描述起来不方便、不形象、不直观。 软件的硬件性表现在软件的运行与硬件的关系密切、与硬件环境的相关性非常高、不同硬件中的软件许多都互不通用。 5、什么是软件危机？&emsp;&emsp;软件危机是指在计算机的开发和维护过程中所遇到的一系列严重问题。6、软件危机的表现有哪些？&emsp;&emsp;软件危机的典型表现： 对软件开发成本和进度的估计常常很不准确； 用户对“已完成的”软件系统不满意的现象经常发生； 软件产品的质量往往靠不住； 软件常常是不可维护的； 软件通常没有适当的文档资料； 软件成本在计算机系统总成本中所占比例逐年上升； 软件开发生产率提高的速度，远远跟不上计算机应用迅速普及深入的趋势。 7、如何消除软件危机？&emsp;&emsp;消除软件危机的途径： 首先应该对计算机软件有一个正确的认识，软件是程序、数据及相关文档的完整集合； 必须充分吸取和借鉴前人行之有效的原理、概念、技术和方法； 推广使用在实践中成功的技术和方法； 开发和使用更好的软件工具； 既要有技术措施（方法和工具），又要有必要的组织管理措施。软件工程正是从管理和技术两方面研究如何更好地开发和维护计算机软件的一门新兴学科。 12、软件工程主要哪几种方法？&emsp;&emsp;面向过程方法、面向数据方法、面向对象方法、形式化方法13、软件工程每种方法的特点？分别适用什么样的软件开发？&emsp;&emsp;面向过程方法：面向过程的方法 ： 面向过程需求分析、面向过程设计、面向过程编程、面向过程测试、面向过程维护、面向过程管理。面向过程的方法，又称为面向功能的方法，或称为结构化方法。 特点：程序的执行过程，不由用户控制,完全由程序员控制。 优点：简单实用。 缺点：企图用有穷的方法(枚举法)来描述无穷的(随机的)信息世界，所以不能完全描述信息世界;维护困难。 适用场合：大型工程计算，实时数据跟踪处理，各种自动化控制系统，以及系统软件实现等领域。 &emsp;&emsp;面向数据的方法：面向元数据的方法，是建设数据库和数据仓库的基本方法。&emsp;&emsp;内容：1.数据位于信息系统的中心。2.由元数据构成的数据模型是稳定的。3.对元数据的处理方法是可变的。4.企业信息系统的核心是数据模型。5.系统的实现方法主要是面向对象。 特点：程序的执行过程，有时由程序员控制，有时由用户控制。 优点：适合数据层设计与实现。 缺点：实现窗口界面较困难。 适用场合：互联网络时代，完全由用户交互控制程序执行过程的应用软件和系统软件的开发。 &emsp;&emsp;面向对象方法：面向对象需求分析、面向对象设计、面向对象编程、面向对象测试、面向对象维护、面向对象管理。 &emsp;&emsp;面向对象方法=对象+类+继承+消息 特点：(1)程序的执行过程，不由程序员控制，完全由用户控制。&emsp;&emsp;&emsp;(2)分析设计时面向类，编程时面向对象。 优点：用无穷的方法来描述无穷的(随机的)信息世界，所以能完全描述信息世界；易于维护。· 缺点：较难掌握。 适用场合：以关系数据库管理系统为支撑环境的信息系统建设。 &emsp;&emsp;形式化方法：数学方法:用数据的语言描述、推导、验证。 优点:：严谨，无二义性，验证结果可靠。 不足：对于不能够形式化的大型、复杂软件不适用。 适用场合：对安全性要求极高，不容许出错的软件系统，如军事、医药、交通等领域。 14、如何延长软件的生命周期？15、有哪些常见的软件过程模型？ &emsp;&emsp;瀑布模型、原型模型、增量模型、螺旋模型、喷泉模型、统一过程、敏捷过程等。]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之137]]></title>
    <url>%2F2020%2F02%2F03%2Fleetcode-shua-ti-ji-lu-zhi-137%2F</url>
    <content type="text"><![CDATA[137、只出现一次的数字 II&emsp;&emsp;给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。说明：&emsp;&emsp;你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？示例 1： 输入: [2,2,3,2] 输出: 3 示例 2： 输入: [0,1,0,1,0,1,99] 输出: 99 难度：中等&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/single-number-ii/ 1、C语言代码：int singleNumber(int* nums, int numsSize){ int one = 0,two = 0; for (unsigned int i = 0; i &lt; numsSize; i++) { one = one ^ nums[i] &amp; ~two; two = two ^ nums[i] &amp; ~one; } return one; } 解释： 参考。 知识点回顾： 位操作。 2、Java代码：class Solution { public int singleNumber(int[] nums) { Arrays.sort(nums); for (int i=0,j=1;j&lt;nums.length;i+=3,j+=3) { if (nums[i] != nums[j]) return nums[i]; } return nums[nums.length-1]; } } 解释： 先排序，再双指针循环遍历，查询是否相等，如果到最后还没有找到不同，那肯定是数组最后一个。 知识点回顾： 无。 3、Python代码：class Solution: def singleNumber(self, nums: List[int]) -> int: return (sum(set(nums))*3 - sum(nums)) // 2 解释： 观察发现，数组去重后的和*3跟原来的数组的和刚好相差要找元素的2倍。 知识点回顾： 无。 4、JavaScript代码：/** * @param {number[]} nums * @return {number} */ var singleNumber = function(nums) { nums = nums.sort((a, b) => a - b); for(var i = 2; i &lt; nums.length; i += 3){ if((nums[i] + nums[i - 1] + nums[i - 2]) !== nums[i]*3){ return nums[i] ^ nums[i - 1] ^ nums[i - 2] } } return nums[nums.length - 1]; }; 解释： 排序，升序或降序均可。 循环，每三组进行相加，并判断是否等于第一项的三倍。 相同的话说明三个数字相同。 不同的话，说明肯定存在不同的数字。 进行异或。 循环完后还没有，则最后一个是。 知识点回顾： 无。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode中等题</tag>
        <tag>位操作</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之540]]></title>
    <url>%2F2019%2F12%2F15%2Fleetcode-shua-ti-ji-lu-zhi-540%2F</url>
    <content type="text"><![CDATA[540、有序数组中的单一元素&emsp;&emsp;给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。示例 1： 输入: [1,1,2,3,3,4,4,8,8] 输出: 2 示例 2： 输入: [3,3,7,7,10,11,11] 输出: 10 注意: 您的方案应该在 O(log n)时间复杂度和 O(1)空间复杂度中运行。难度：中等&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/single-element-in-a-sorted-array/ 1、C语言代码:int singleNonDuplicate(int* nums, int numsSize){ int left=0,right=numsSize-1; while(left&lt;right){ int mid = left + (right - left) / 2; if(mid%2==1){ if(nums[mid]==nums[mid+1]) right=mid-1; else left=mid+1; }else{ if(nums[mid]==nums[mid+1]) left=mid+2; else right=mid; } } return nums[left]; } 解释： 因为是有序数组，所以可以用二分法。思路：取数组中间的数，当中间数的下标为奇数，说明前后元素的个数为奇数，偶数则剩余个数为偶数。奇数时：当nums[mid]等于[mid+1],唯一数处于前mid-1,反之处于后mid+1。偶数时：当nums[mid]等于[mid+1]，唯一数处于后mid+2,反之处于前mid.(就是要保证剩余查找元素个数奇数) 知识点回顾： 无。 2、Java代码:class Solution { public int singleNonDuplicate(int[] nums) { int num = 0; for(int i : nums) num ^= i; return num; } } 解释： 直接用位运算，已知两个相同的数异或之后为0，所以把数组所有的数都异或了之后就是剩下的值了。 知识点回顾： ^的运算法则：只有在两个比较的位不同时其结果是1，否则结果为0。 3、Python代码：class Solution: def singleNonDuplicate(self, nums: List[int]) -> int: return 2*sum(set(nums)) - sum(nums) 解释： 将原数组去重*2，减去原数组，剩下的就是唯一的值。 知识点回顾： 无。 4、JavaScript代码：/** * @param {number[]} nums * @return {number} */ var singleNonDuplicate = function(nums) { for(let i = 0; i&lt;nums.length;i+=2){ if(nums[i]!=nums[i+1]) return nums[i] } }; 解释： 因为有序数是成对出现，所以特殊数出现的下标一定是偶数位，所以只需要拿偶数位下标去跟下一位下标的值去比较即可。 知识点回顾： 无。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode中等题</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之292]]></title>
    <url>%2F2019%2F12%2F11%2Fleetcode-shua-ti-ji-lu-zhi-292%2F</url>
    <content type="text"><![CDATA[292、 Nim 游戏&emsp;&emsp;你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。&emsp;&emsp;你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。示例： 输入: 4 输出: false 解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛； 因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/nim-game/ 1、C语言代码：bool canWinNim(int n){ return n % 4; } 解释： 如果堆中石头的数量 n 不能被 4 整除，那么你总是可以赢得 Nim 游戏的胜利。让我们考虑一些小例子。显而易见的是，如果石头堆中只有一块、两块、或是三块石头，那么在你的回合，你就可以把全部石子拿走，从而在游戏中取胜。而如果就像题目描述那样，堆中恰好有四块石头，你就会失败。因为在这种情况下不管你取走多少石头，总会为你的对手留下几块，使得他可以在游戏中打败你。因此，要想获胜，在你的回合中，必须避免石头堆中的石子数为 4 的情况。同样地，如果有五块、六块、或是七块石头，你可以控制自己拿取的石头数，总是恰好给你的对手留下四块石头，使他输掉这场比赛。但是如果石头堆里有八块石头，你就不可避免地会输掉，因为不管你从一堆石头中挑出一块、两块还是三块，你的对手都可以选择三块、两块或一块，以确保在再一次轮到你的时候，你会面对四块石头。显然，它以相同的模式不断重复 n=4,8,12,16,…，基本可以看出是 4 的倍数。 知识点回顾： 无。 2、Java代码:class Solution { public boolean canWinNim(int n) { return (n % 4 != 0); } } 解释： 类似于C语言的求解思路。 知识点回顾： 无。 3、Python代码：class Solution: def canWinNim(self, n: int) -> bool: return n % 4 解释： 类似于C语言的求解思路。 知识点回顾： 无。 4、JavaScript代码：/** * @param {number} n * @return {boolean} */ var canWinNim = function(n) { return n % 4 }; 解释： 类似于C语言的求解思路。 知识点回顾： 无。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之852]]></title>
    <url>%2F2019%2F12%2F09%2Fleetcode-shua-ti-ji-lu-zhi-852%2F</url>
    <content type="text"><![CDATA[852、山脉数组的峰顶索引我们把符合下列属性的数组 A 称作山脉： A.length &gt;= 3 存在 0 &lt; i &lt; A.length - 1 使得A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1] 给定一个确定为山脉的数组，返回任何满足 A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1] 的 i 的值。示例 1： 输入：[0,1,0] 输出：1 示例 2： 输入：[0,2,1,0] 输出：1 提示： 3 &lt;= A.length &lt;= 10000 0 &lt;= A[i] &lt;= 10^6 A 是如上定义的山脉 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/ 1、C语言代码：int peakIndexInMountainArray(int* A, int ASize){ int i = 0; while (A[i] &lt; A[i+1]) i++; return i; } 解释： 从左往右扫描直到山的高度不再增长为止，停止增长点就是峰顶。 知识点回顾： 无。 2、Java代码：class Solution { public int peakIndexInMountainArray(int[] A) { int lo = 0, hi = A.length - 1; while (lo &lt; hi) { int mi = lo + (hi - lo) / 2; if (A[mi] &lt; A[mi + 1]) lo = mi + 1; else hi = mi; } return lo; } } 解释： 将山脉数组中所有满足 A[i] &lt; A[i+1] 的 i 点标记为 True，不满足的点标记为 False。则一个山脉数组可以标记为：[True, True, True, …, True, False, False, …, False]。例如山脉数组 [1, 2, 3, 4, 1] 可以标记为 True, True, True, False。 知识点回顾： 无。 3、Python代码：class Solution: def peakIndexInMountainArray(self, A: List[int]) -> int: return A.index(max(A)) 解释： 直接利用语言内置函数求解。 知识点回顾： 无。 4、JavaScript代码：/** * @param {number[]} A * @return {number} */ var peakIndexInMountainArray = function(A) { return A.indexOf(Math.max(...A)) }; 解释： 直接利用语言内置函数求解。 知识点回顾： 无。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之1221]]></title>
    <url>%2F2019%2F12%2F07%2Fleetcode-shua-ti-ji-lu-zhi-1221%2F</url>
    <content type="text"><![CDATA[1221、分割平衡字符串在一个「平衡字符串」中，’L’ 和 ‘R’ 字符的数量是相同的。给出一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。返回可以通过分割得到的平衡字符串的最大数量。示例 1： 输入：s = &quot;RLRRLLRLRL&quot; 输出：4 解释：s 可以分割为 &quot;RL&quot;, &quot;RRLL&quot;, &quot;RL&quot;, &quot;RL&quot;, 每个子字符串中都包含相同数量的 &#39;L&#39; 和 &#39;R&#39;。 示例 2： 输入：s = &quot;RLLLLRRRLR&quot; 输出：3 解释：s 可以分割为 &quot;RL&quot;, &quot;LLLRRR&quot;, &quot;LR&quot;, 每个子字符串中都包含相同数量的 &#39;L&#39; 和 &#39;R&#39;。 示例 3： 输入：s = &quot;LLLLRRRR&quot; 输出：1 解释：s 只能保持原样 &quot;LLLLRRRR&quot;. 提示： 1 &lt;= s.length &lt;= 1000 s[i] = ‘L’ 或 ‘R’ 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/split-a-string-in-balanced-strings/ 1、C语言代码：int balancedStringSplit(char * s){ int sum = 0,rlsum = 0; for(int i = 0;s[i] != '\0';i++){ if(s[i] =='R') rlsum++; else rlsum--; if(rlsum == 0) sum++; } return sum; } 解释： 当R和L互相抵消时记录为0就好了。 知识点回顾： 无。 2、Java代码：class Solution { public int balancedStringSplit(String s) { int stack = 0,cnt = 0; for(char c: s.toCharArray()) { if(c == 'R') stack--; else stack++; if(stack == 0) cnt++; } return cnt; } } 解释： 类似于C语言的求解思路。 知识点回顾： 无。 3、Python代码：class Solution: def balancedStringSplit(self, s: str) -> int: return list(itertools.accumulate(map(lambda c: 1 if c == 'L' else -1, s))).count(0) 解释： 类似于C语言的求解思路。 知识点回顾： 无。 4、JavaScript代码：/** * @param {string} s * @return {number} */ var balancedStringSplit = function(s) { let step = 0, ans = 0; for(let i = 0; i &lt; s.length;i++){ s[i] == 'R' ? step++ : step-- step == 0 &amp;&amp; ans++ } return ans }; 解释： 类似于C语言的求解思路。 知识点回顾： 无。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>贪心算法</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之704]]></title>
    <url>%2F2019%2F12%2F04%2Fleetcode-shua-ti-ji-lu-zhi-704%2F</url>
    <content type="text"><![CDATA[704、二分查找&emsp;&emsp;给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。示例 1: 输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 示例 2： 输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 提示： 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/binary-search/ 1、C语言代码:int search(int* nums, int numsSize, int target){ for(int i = 0;i &lt; numsSize;i++){ if(nums[i] == target) return i; } return -1; } 解释： 顺序遍历查找。 知识点回顾： 无。 2、Java代码:class Solution { public int search(int[] nums, int target) { int left = 0; int right = nums.length - 1; while(left &lt;= right) { //可以防止left+right溢出（超出整数范围） int mid = left + ((right - left)>>2); if(nums[mid] == target) return mid; else if (nums[mid] &lt; target) left = mid + 1; else if (nums[mid] > target) right = mid - 1; } return -1; } } 解释： 二分查找法。 知识点回顾： 无。 3、Python代码：class Solution: def search(self, nums: List[int], target: int) -> int: i = bisect.bisect(nums, target) return i - 1 if nums[i - 1] == target else -1 解释： 利用Python的模块求解。 知识点回顾：1、Python 有一个 bisect 模块，用于维护有序列表。bisect 模块实现了一个算法用于插入元素到有序列表。在一些情况下，这比反复排序列表或构造一个大的列表再排序的效率更高。Bisect 是二分法的意思，这里使用二分法来排序，它会将一个元素插入到一个有序列表的合适位置，这使得不需要每次调用 sort 的方式维护有序列表。bisect.bisect_left(a,x, lo=0, hi=len(a))查找在有序列表 a 中插入 x 的index。lo 和 hi 用于指定列表的区间，默认是使用整个列表。如果 x 已经存在，在其左边插入。返回值为 index。bisect.bisect_right(a,x, lo=0, hi=len(a))bisect.bisect(a, x,lo=0, hi=len(a))这2个函数和 bisect_left 类似，但如果 x 已经存在，在其右边插入。bisect.insort_left(a,x, lo=0, hi=len(a))在有序列表 a 中插入 x。和 a.insert(bisect.bisect_left(a,x, lo, hi), x) 的效果相同。bisect.insort_right(a,x, lo=0, hi=len(a))bisect.insort(a, x,lo=0, hi=len(a))和 insort_left 类似，但如果 x 已经存在，在其右边插入。Bisect 模块提供的函数可以分两类： bisect 只用于查找 index， 不进行实际的插入；而 insort 则用于实际插入。 4、JavaScript代码：/** * @param {number[]} nums * @param {number} target * @return {number} */ var search = function(nums, target) { return nums.indexOf(target) }; 解释： 直接利用函数。 知识点回顾：1、indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。如果没有找到匹配的字符串则返回 -1。注意： indexOf() 方法区分大小写。语法：string.indexOf(searchvalue,start)searchvalue：必需。规定需检索的字符串值。start：可选的整数参数。规定在字符串中开始检索的位置。它的合法取值是 0 到 string Object.length - 1。如省略该参数，则将从字符串的首字符开始检索。返回值：查找指定字符串第一次出现的位置，如果没找到匹配的字符串则返回 -1。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之287]]></title>
    <url>%2F2019%2F12%2F03%2Fleetcode-shua-ti-ji-lu-zhi-287%2F</url>
    <content type="text"><![CDATA[287、寻找重复数&emsp;&emsp;给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。示例 1： 输入: [1,3,4,2,2] 输出: 2 示例 2： 输入: [3,1,3,4,2] 输出: 3 说明： 不能更改原数组（假设数组是只读的）。 只能使用额外的 O(1) 的空间。 时间复杂度小于 O(n2) 。 数组中只有一个重复的数字，但它可能不止重复出现一次。 难度：中等&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/find-the-duplicate-number/ 1、C语言代码：//解法一：暴力法 int findDuplicate(int* nums, int numsSize){ for(int i = 0;i &lt; numsSize - 1;i++){ for(int j = i + 1;j &lt; numsSize;j++){ if(nums[i] == nums[j]) return nums[i]; } } return; } //解法二：排序法 int cmp(const void *a, const void *b){ return (*(int *)a - *(int *)b); } int findDuplicate(int* nums, int numsSize){ qsort(nums, numsSize, sizeof(int), cmp); for (int i = 0; i &lt; numsSize - 1; i++) { if (nums[i] == nums[i + 1]) { return nums[i]; } } return; } 解释： 方法一暴力求解，双重循环判断是否有重复数。方法二：如果对数字进行排序，则任何重复的数字都将与排序后的数组相邻。 知识点回顾： 无。 2、Java代码://解法一：集合 class Solution { public int findDuplicate(int[] nums) { Set&lt;Integer> seen = new HashSet&lt;Integer>(); for (int num : nums) { if (seen.contains(num)) { return num; } seen.add(num); } return -1; } } //解法二：快慢指针法 class Solution { public int findDuplicate(int[] nums) { int length = nums.length; if (length > 1) { // 找到快慢指针相遇的地方 int slow = nums[0]; int fast = nums[nums[0]]; while (fast != slow) { slow = nums[slow]; fast = nums[nums[fast]]; } // 用一个新指针从头开始，直到和慢指针相遇 fast = 0; while (fast != slow) { slow = nums[slow]; fast = nums[fast]; } return slow; } return -1; } } 解释： 方法一：如果我们在数组上迭代时存储每个元素，我们可以在数组上迭代时简单地检查每个元素。为了实现线性时间复杂性，我们需要能够在恒定时间内将元素插入数据结构（并查找它们）。set 很好地满足这些约束，所以我们迭代数组并将每个元素插入 seen 中。在插入之前，我们检查它是否已经存在。如果是，那么我们找到了我们的副本，所以我们返回它。方法二：假设数组中没有重复，那我们可以做到这么一点，就是将数组的下标和1到n每一个数一对一的映射起来。比如数组是213,则映射关系为0-&gt;2, 1-&gt;1, 2-&gt;3。假设这个一对一映射关系是一个函数f(n)，其中n是下标，f(n)是映射到的数。如果我们从下标为0出发，根据这个函数计算出一个值，以这个值为新的下标，再用这个函数计算，以此类推，直到下标超界。实际上可以产生一个类似链表一样的序列。比如在这个例子中有两个下标的序列，0-&gt;2-&gt;3。但如果有重复的话，这中间就会产生多对一的映射，比如数组2131,则映射关系为0-&gt;2, {1，3}-&gt;1, 2-&gt;3。这样，我们推演的序列就一定会有环路了，这里下标的序列是0-&gt;2-&gt;3-&gt;1-&gt;1-&gt;1-&gt;1-&gt;…，而环的起点就是重复的数。所以该题实际上就是找环路起点的题。过程是这样的：我们先用快慢两个下标都从0开始，快下标每轮映射两次，慢下标每轮映射一次，直到两个下标再次相同。这时候保持慢下标位置不变，再用一个新的下标从0开始，这两个下标都继续每轮映射一次，当这两个下标相遇时，就是环的起点，也就是重复的数。 知识点回顾： 无。 3、Python代码：class Solution: def findDuplicate(self, nums: List[int]) -> int: return int(abs(sum(nums)-sum(set(nums)))/abs(len(nums)-len(set(nums)))) 解释： 重复数字是原始数组和求集合后的差值除以长度差。 知识点回顾： 无。 4、JavaScript代码：/** * @param {number[]} nums * @return {number} */ var findDuplicate = function(nums) { for(let i = 0;i &lt; nums.length;i++){ if(nums.indexOf(nums[i]) !== nums.lastIndexOf(nums[i])){ return nums[i] } } }; 解释： 直接判断。 知识点回顾：1、indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。如果没有找到匹配的字符串则返回 -1。注意： indexOf() 方法区分大小写。语法：string.indexOf(searchvalue,start)searchvalue：必需。规定需检索的字符串值。start：可选的整数参数。规定在字符串中开始检索的位置。它的合法取值是 0 到 string Object.length - 1。如省略该参数，则将从字符串的首字符开始检索。返回值：查找指定字符串第一次出现的位置，如果没找到匹配的字符串则返回 -1。2、lastIndexOf() 方法可返回一个指定的字符串值最后出现的位置，如果指定第二个参数 start，则在一个字符串中的指定位置从后向前搜索。注意： 该方法将从后向前检索字符串，但返回是从起始位置 (0) 开始计算子字符串最后出现的位置。 看它是否含有字符串。开始检索的位置在字符串的 start 处或字符串的结尾（没有指定 start 时）。如果没有找到匹配字符串则返回 -1 。注意：lastIndexOf() 方法是区分大小写的！语法：string.lastIndexOf(searchvalue,start)searchvalue：必需。规定需检索的字符串值。start：可选的整数参数。规定在字符串中开始检索的位置。它的合法取值是 0 到 stringObject.length - 1。如省略该参数，则将从字符串的最后一个字符处开始检索。返回值：查找的字符串最后出现的位置，如果没有找到匹配字符串则返回 -1。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>leetcode中等题</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之1252]]></title>
    <url>%2F2019%2F12%2F02%2Fleetcode-shua-ti-ji-lu-zhi-1252%2F</url>
    <content type="text"><![CDATA[1252、奇数值单元格的数目&emsp;&emsp;给你一个 n 行 m 列的矩阵，最开始的时候，每个单元格中的值都是 0。&emsp;&emsp;另有一个索引数组 indices，indices[i] = [ri, ci] 中的 ri 和 ci 分别表示指定的行和列（从 0 开始编号）。&emsp;&emsp;你需要将每对 [ri, ci] 指定的行和列上的所有单元格的值加 1。&emsp;&emsp;请你在执行完所有 indices 指定的增量操作后，返回矩阵中 「奇数值单元格」 的数目。示例 1： 输入：n = 2, m = 3, indices = [[0,1],[1,1]] 输出：6 解释：最开始的矩阵是 [[0,0,0],[0,0,0]]。 第一次增量操作后得到 [[1,2,1],[0,1,0]]。 最后的矩阵是 [[1,3,1],[1,3,1]]，里面有 6 个奇数。 示例 2： 输入：n = 2, m = 2, indices = [[1,1],[0,0]] 输出：0 解释：最后的矩阵是 [[2,2],[2,2]]，里面没有奇数。 提示： 1 &lt;= n &lt;= 50 1 &lt;= m &lt;= 50 1 &lt;= indices.length &lt;= 100 0 &lt;= indices[i][0] &lt; n 0 &lt;= indices[i][1] &lt; m 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/cells-with-odd-values-in-a-matrix/ 1、C语言代码：int oddCells(int n, int m, int** indices, int indicesSize, int* indicesColSize){ int res = 0; int i, j; int *a = (int*)malloc(n * sizeof(int)); memset(a, 0, n*sizeof(int)); int *b = (int*)malloc(m * sizeof(int)); memset(b, 0, m*sizeof(int)); for (i = 0; i &lt; indicesSize; i++){ a[indices[i][0]] = (a[indices[i][0]]+1)%2; b[indices[i][1]] = (b[indices[i][1]]+1)%2; } for (i = 0; i &lt; n; i++){ for (j = 0; j &lt; m; j++){ if (a[i] != b[j]) res++; } } return res; } 解释： 分别统计行和列出现的次数的奇偶性，然后行列进行重合，奇偶性相同为偶数，不同为奇数。 知识点回顾： 无。 2、Java代码：class Solution { public int oddCells(int n, int m, int[][] indices) { int[] row=new int[n]; int[] col=new int[m]; for(int i=0;i&lt;indices.length;i++) { row[indices[i][0]]++; col[indices[i][1]]++; } int ans=0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) { if((row[i]+col[j])%2>0) ans++; } return ans; } } 解释： 直接记一下行数和列数出现的次数即可。 知识点回顾： 无。 3、Python代码：class Solution: def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int: from collections import Counter rowCounter, colCounter = Counter(), Counter() for r, c in indices: rowCounter[r] += 1 colCounter[c] += 1 ans = 0 for i in range(n): for j in range(m): if (rowCounter[i] + colCounter[j]) % 2: ans += 1 return ans 解释： 类似于C语言的求解思路。 知识点回顾： 无。 4、JavaScript代码：/** * @param {number} n * @param {number} m * @param {number[][]} indices * @return {number} */ var oddCells = function(n, m, indices) { let row = new Array(n).fill(0) let col = new Array(m).fill(0) let sum = 0 for(let i = 0 ; i &lt; indices.length; i++){ row[indices[i][0]] = row[indices[i][0]] ^ 1 } let cnt_row = 0 row.forEach((i)=>{cnt_row += i}) let diff = n-cnt_row for(let i = 0 ; i &lt; indices.length; i++){ col[indices[i][1]] = col[indices[i][1]] ^ 1 } col.forEach((i)=>{ if(i == 1){ sum+=diff } else{ sum+=cnt_row } }) return sum }; 解释： 先统计行的翻转情况，再统计列的翻转情况。 若某一列翻转了偶数次sum加上行反转次数，若某一列翻转了奇数次sum加上n行反转次数。 知识点回顾： 无。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>数组</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之1266]]></title>
    <url>%2F2019%2F12%2F02%2Fleetcode-shua-ti-ji-lu-zhi-1266%2F</url>
    <content type="text"><![CDATA[1266、访问所有点的最小时间平面上有 n 个点，点的位置用整数坐标表示 points[i] = [xi, yi]。请你计算访问所有这些点需要的最小时间（以秒为单位）。你可以按照下面的规则在平面上移动： 每一秒沿水平或者竖直方向移动一个单位长度，或者跨过对角线（可以看作在一秒内向水平和竖直方向各移动一个单位长度）。 必须按照数组中出现的顺序来访问这些点。 示例 1： 输入：points = [[1,1],[3,4],[-1,0]] 输出：7 解释：一条最佳的访问路径是： [1,1] -&gt; [2,2] -&gt; [3,3] -&gt; [3,4] -&gt; [2,3] -&gt; [1,2] -&gt; [0,1] -&gt; [-1,0] 从 [1,1] 到 [3,4] 需要 3 秒 从 [3,4] 到 [-1,0] 需要 4 秒 一共需要 7 秒 示例 2： 输入：points = [[3,2],[-2,2]] 输出：5 提示： points.length == n1 &lt;= n &lt;= 100points[i].length == 2-1000 &lt;= points[i][0], points[i][1] &lt;= 1000 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/minimum-time-visiting-all-points/ 1、C语言代码：int minTimeToVisitAllPoints(int** points, int pointsSize, int* pointsColSize){ int sum = 0; for (int i = 0;i &lt; pointsSize - 1;i++){ if (abs(points[i][0]-points[i+1][0])>abs(points[i][1]-points[i+1][1])) sum+=abs(points[i][0]-points[i+1][0]); else sum+=abs(points[i][1]-points[i+1][1]); } return sum; } 解释： 其实本题很好理解，按照题意，2点之间最佳路径的最少次数就是2点横纵坐标相减绝对值大的数的值。 知识点回顾： 无。 2、Java代码：class Solution { public int minTimeToVisitAllPoints(int[][] points) { int sum = 0,i; for(i = 0;i &lt; points.length - 1;i++){ sum += Math.max(Math.abs(points[i][0]-points[i+1][0]),Math.abs(points[i][1]-points[i+1][1])); } return sum; } } 解释： 类似于C语言的求解思路。 知识点回顾： 无。 3、Python代码：class Solution: def minTimeToVisitAllPoints(self, points: List[List[int]]) -> int: return sum(max(abs(points[i][0] - points[i - 1][0]), abs(points[i][1] - points[i - 1][1])) for i in range(1, len(points))) 解释： 类似于C语言的求解思路。 知识点回顾： 无。 4、JavaScript代码：/** * @param {number[][]} points * @return {number} */ var minTimeToVisitAllPoints = function(points) { let sum=0,i; for (i=0;i&lt;points.length-1;i++){ if (Math.abs(points[i][0]-points[i+1][0])>Math.abs(points[i][1]-points[i+1][1])) sum+=Math.abs(points[i][0]-points[i+1][0]); else sum+=Math.abs(points[i][1]-points[i+1][1]); } return sum; }; 解释： 类似于C语言的求解思路。 知识点回顾： 无。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>数组</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之34]]></title>
    <url>%2F2019%2F12%2F01%2Fleetcode-shua-ti-ji-lu-zhi-34%2F</url>
    <content type="text"><![CDATA[34、在排序数组中查找元素的第一个和最后一个位置&emsp;&emsp;给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。&emsp;&emsp;你的算法时间复杂度必须是 O(log n) 级别。&emsp;&emsp;如果数组中不存在目标值，返回 [-1, -1]。示例 1： 输入: nums = [5,7,7,8,8,10], target = 8 输出: [3,4] 示例 2： 输入: nums = [5,7,7,8,8,10], target = 6 输出: [-1,-1] 难度：中等&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/ 1、C语言代码：//解法一： /** * Note: The returned array must be malloced, assume caller calls free(). */ int* searchRange(int* nums, int numsSize, int target, int* returnSize){ int *result = (int *)malloc(sizeof(int) * 2); int i = 0,j = numsSize - 1; while(i&lt;j){ if(nums[i]==target&amp;&amp;nums[j]==target) break; if(nums[i]&lt;target&amp;&amp;nums[j]>target){ i++; j--; } if(nums[i]&lt;target&amp;&amp;nums[j]==target) i++; if(nums[i]==target&amp;&amp;nums[j]>target) j--; if(nums[i]>target||nums[j]&lt;target) break; } if((i==j&amp;&amp;nums[i]!=target)||(numsSize==0)||(nums[i]>target)||(nums[j]&lt;target)){ result[0] = -1; result[1] = -1; *returnSize = 2; return result; } else{ result[0] = i; result[1] = j; *returnSize = 2; return result; } } //解法二 /** * Note: The returned array must be malloced, assume caller calls free(). */ int* searchRange(int* nums, int numsSize, int target, int* returnSize){ int i ,j; int *res = (int*)malloc(sizeof(int)*2); *returnSize = 2; res[0] = res[1] = -1; if(numsSize == 0){ return res; } for(i = 0;i &lt; numsSize;i++){ if(nums[i] == target){ res[0] = i; break; } } for(j = numsSize - 1;j >= 0;j--){ if(nums[j] == target){ res[1] = j; break; } } return res; } 解释： 解法一利用双指针，综合考虑各种情况；解法二则2次遍历数组得出答案。 知识点回顾： 无。 2、Java代码：class Solution { // returns leftmost (or rightmost) index at which `target` should be // inserted in sorted array `nums` via binary search. private int extremeInsertionIndex(int[] nums, int target, boolean left) { int lo = 0; int hi = nums.length; while (lo &lt; hi) { int mid = (lo + hi) / 2; if (nums[mid] > target || (left &amp;&amp; target == nums[mid])) { hi = mid; } else { lo = mid+1; } } return lo; } public int[] searchRange(int[] nums, int target) { int[] targetRange = {-1, -1}; int leftIdx = extremeInsertionIndex(nums, target, true); // assert that `leftIdx` is within the array bounds and that `target` // is actually in `nums`. if (leftIdx == nums.length || nums[leftIdx] != target) { return targetRange; } targetRange[0] = leftIdx; targetRange[1] = extremeInsertionIndex(nums, target, false)-1; return targetRange; } } 解释： 总体算法工作过程与线性扫描方法类似，除了找最左和最右下标的方法。这里我们仅仅做几个微小的调整，用这种修改过的二分查找方法去搜索这个排过序的数组。首先，为了找到最左边（或者最右边）包含 target 的下标（而不是找到的话就返回 true ），所以算法在我们找到一个 target 后不能马上停止。我们需要继续搜索，直到 lo \=\= hi 且它们在某个 target 值处下标相同。&emsp;&emsp;另一个改变是 left 参数的引入，它是一个 boolean 类型的变量，指示我们在遇到 target \=\= nums[mid] 时应该做什么。如果 left 为 true ，那么我们递归查询左区间，否则递归右区间。考虑如果我们在下标为 i 处遇到了 target ，最左边的 target 一定不会出现在下标大于 i 的位置，所以我们永远不需要考虑右子区间。当求最右下标时，道理同样适用。 知识点回顾： 无。 3、Python代码：class Solution: def searchRange(self, nums: List[int], target: int) -> List[int]: l = bisect.bisect_left(nums,target) r = bisect.bisect_right(nums,target) if l >= len(nums) or nums[l] != target: return [-1,-1] return [l,r-1] 解释： 利用Python的模块求解。 知识点回顾：1、Python 有一个 bisect 模块，用于维护有序列表。bisect 模块实现了一个算法用于插入元素到有序列表。在一些情况下，这比反复排序列表或构造一个大的列表再排序的效率更高。Bisect 是二分法的意思，这里使用二分法来排序，它会将一个元素插入到一个有序列表的合适位置，这使得不需要每次调用 sort 的方式维护有序列表。bisect.bisect_left(a,x, lo=0, hi=len(a))查找在有序列表 a 中插入 x 的index。lo 和 hi 用于指定列表的区间，默认是使用整个列表。如果 x 已经存在，在其左边插入。返回值为 index。bisect.bisect_right(a,x, lo=0, hi=len(a))bisect.bisect(a, x,lo=0, hi=len(a))这2个函数和 bisect_left 类似，但如果 x 已经存在，在其右边插入。bisect.insort_left(a,x, lo=0, hi=len(a))在有序列表 a 中插入 x。和 a.insert(bisect.bisect_left(a,x, lo, hi), x) 的效果相同。bisect.insort_right(a,x, lo=0, hi=len(a))bisect.insort(a, x,lo=0, hi=len(a))和 insort_left 类似，但如果 x 已经存在，在其右边插入。Bisect 模块提供的函数可以分两类： bisect 只用于查找 index， 不进行实际的插入；而 insort 则用于实际插入。 4、JavaScript代码：/** * @param {number[]} nums * @param {number} target * @return {number[]} */ var searchRange = function(nums, target) { return [nums.indexOf(target), nums.lastIndexOf(target)] }; 解释： 利用JavaScript自带方法求解。 知识点回顾：1、indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。如果没有找到匹配的字符串则返回 -1。注意： indexOf() 方法区分大小写。语法：string.indexOf(searchvalue,start)searchvalue：必需。规定需检索的字符串值。start：可选的整数参数。规定在字符串中开始检索的位置。它的合法取值是 0 到 string Object.length - 1。如省略该参数，则将从字符串的首字符开始检索。返回值：查找指定字符串第一次出现的位置，如果没找到匹配的字符串则返回 -1。2、lastIndexOf() 方法可返回一个指定的字符串值最后出现的位置，如果指定第二个参数 start，则在一个字符串中的指定位置从后向前搜索。注意： 该方法将从后向前检索字符串，但返回是从起始位置 (0) 开始计算子字符串最后出现的位置。 看它是否含有字符串。开始检索的位置在字符串的 start 处或字符串的结尾（没有指定 start 时）。如果没有找到匹配字符串则返回 -1 。注意：lastIndexOf() 方法是区分大小写的！语法：string.lastIndexOf(searchvalue,start)searchvalue：必需。规定需检索的字符串值。start：可选的整数参数。规定在字符串中开始检索的位置。它的合法取值是 0 到 stringObject.length - 1。如省略该参数，则将从字符串的最后一个字符处开始检索。返回值：查找的字符串最后出现的位置，如果没有找到匹配字符串则返回 -1。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode中等题</tag>
        <tag>双指针</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之167]]></title>
    <url>%2F2019%2F12%2F01%2Fleetcode-shua-ti-ji-lu-zhi-167%2F</url>
    <content type="text"><![CDATA[167、两数之和 II - 输入有序数组给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。说明： 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例： 输入: numbers = [2, 7, 11, 15], target = 9 输出: [1,2] 解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/ 1、C语言代码：/** * Note: The returned array must be malloced, assume caller calls free(). */ int* twoSum(int* numbers, int numbersSize, int target, int* returnSize){ int *result = (int *)malloc(sizeof(int) * 2); int i = 0,j = numbersSize - 1; while(i&lt;j){ if(numbers[i] + numbers[j] == target) break; if(numbers[i] + numbers[j] &lt; target) i++; else j--; } result[0] = i + 1; result[1] = j + 1; *returnSize = 2; return result; } 解释： 我们使用两个指针，初始分别位于第一个元素和最后一个元素位置，比较这两个元素之和与目标值的大小。如果和等于目标值，我们发现了这个唯一解。如果比目标值小，我们将较小元素指针增加一。如果比目标值大，我们将较大指针减小一。移动指针后重复上述比较知道找到答案。 知识点回顾： 无。 2、Java代码：class Solution { public int[] twoSum(int[] numbers, int target) { int []result = new int[2]; int i = 0,j = numbers.length - 1; while(i&lt;j){ if(numbers[i] + numbers[j] == target) break; if(numbers[i] + numbers[j] > target) j--; else i++; } result[0] = i + 1; result[1] = j + 1; return result; } } 解释： 类似于C语言的解题思路。 知识点回顾： 无。 3、Python代码：class Solution: def twoSum(self, numbers: List[int], target: int) -> List[int]: # 解法1 利用字典映射 dic = dict() for index, value in enumerate(numbers): sub = target - value if sub in dic.keys(): return [dic[sub], index+1] else: dic[value] = index + 1 解释： 利用字典的特性求解。 知识点回顾：1、enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。语法：enumerate(sequence, [start=0])sequence：一个序列、迭代器或其他支持迭代对象。start：下标起始位置。返回值：返回 enumerate(枚举) 对象。 4、JavaScript代码：/** * @param {number[]} numbers * @param {number} target * @return {number[]} */ var twoSum = function(numbers, target) { let map = new Map() for(let i = 0; i &lt; numbers.length; i ++) { if(map.has(target - numbers[i])) { return [map.get(target - numbers[i]) + 1, i + 1] } map.set(numbers[i], i) } }; 解释： 套入题目的例子，遍历数组，数组遍历的当前值为numbers[i]，那么 y 应该是 target - numbers[i]。所以，只要在遍历的时候确定target - numbers[i]在数组里有，返回对应下标。 知识点回顾： 哈希表的运用。1、map.get：返回键对应的值，如果不存在，则返回undefined。2、map.set：设置Map对象中键的值。返回该Map对象。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>哈希表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以梦为马，不负韶华]]></title>
    <url>%2F2019%2F11%2F28%2Fyi-meng-wei-ma-bu-fu-shao-hua%2F</url>
    <content type="text"><![CDATA[以梦为马，不负韶华&emsp;&emsp;昨天是2019年的11月27日，在日常的刷公众号过程中，我看到了一篇文章，标题是《优秀学生专栏：XX：发表学术期刊论文三篇，手握数项大奖》，这并不是我第一次看见这类文章，每次看到这类文章，总会感叹优秀的人太多，可昨天不知怎么了，这种感觉越发强盛，之后无意中发现了学校吴老师的公众号，里面有很多关于生活、人生思考的文章，还有一些优秀的学长学姐的自传，一时间我开始对这个曾经只有几面之缘的老师有了不一样的感觉。&emsp;&emsp;那篇文章的主角是一位专升本的同学，他大一担任学生会主席，丰富的校园经历令我惊讶不已，他积极参加各类竞赛，发表学术期刊，在文字中体现出的绝不仅仅是那几个冷冰冰的奖项，与此同时，他三年参加了约300个小时的志愿服务，更是让我感叹。其实类似这种文章很多，每一位能受邀被采访的同学，要不是在学科竞赛出取得优异的成绩，就是在各种组织社团志愿活动中与人争先。&emsp;&emsp;2017年的时候，我看了清华大学特等奖学金的答辩视频，他们每一个人都是中国最优秀的学生之一。也许在很多人看来，这些离我们太过遥远，所以我也更喜欢看身边的人和事，以同一种身份进入校园，可是很快，就有了区别，有些人成为了老师、学弟学妹的口中的优秀学长学姐，而有些人却开始浑浑噩噩。&emsp;&emsp;在大学有很多人抱怨学校这个不好那个不好，老师上课水，课程水，好像他们混日子的原因就是因为学校，殊不知在他们抱怨的时候，早已有人成为了更优秀的自己。成功最根本的因素还是靠自己。除了上面那个同学之外，去年专升本的同学之中，还有一个技术大佬，在专科的三年，他天天睡在实验室，无数的项目经历让他成功专升本之后就获得了阿里巴巴集团的面试邀请。在我认识的人之中，在他们学校，老师给同学特权，不用上2个月的课，专心竞赛，只要获奖，老师就承诺他这门课给他优秀。学习永远是自己的事情，外界不会改变你内心的坚定。&emsp;&emsp;我的高中校长曾说在中学阶段能在上千人面前做激情澎湃讲演的人，将来一定是有用之人。&emsp;&emsp;以上只是我看了那篇文章之后，一点感想，不成文章。只愿以梦为马，不负韶华。我们都能成为更好的自己。]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本科教育下的计算机相关专业培养方案]]></title>
    <url>%2F2019%2F11%2F25%2Fben-ke-jiao-yu-xia-de-ji-suan-ji-xiang-guan-zhuan-ye-pei-yang-fang-an%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;我的第一篇博客写的是对于计算机专业的相关书籍推荐，时隔3个月，今天我想写一篇关于计算机专业培养方案的博客，我也参考了从普通院校到211/985等院校的相关培养方案。希望对非计算机专业但是想从事IT行业的小伙伴了解计算机专业的培养方案有所帮助。 正文&emsp;&emsp;关于培养方案上面的一些培养目标、毕业要求之类的东西，我在此不多赘述，直接上干货（课程）。1、作为本科教育，一些思政课和公共课是必不可少的。 课程名称 可能修读学期 思想道德修养与法律基础 1或2 中国近代史纲要 1或2 马克思主义基本原理 3或4 毛泽东思想和中国特色社会主义理论体系概论 3或4 军训与军事理论 1 形势与政策 贯穿整个本科教育 体育 1、2、3、4 大学英语 1、2、3、4 2、数学物理作为理工科的基础学科，当然也占了很大的比例。 课程名称 可能修读学期 高等数学(上) 1 高等数学(下) 2 大学物理 1、2 线性代数 2或3 概率论与数理统计 3或4 离散数学 2或3 上述的是大部分学校的课程安排，部分985院校可能会设下列课程： 课程名称 可能修读学期 代数与几何 - 抽象代数 - 数值分析 - 集合论与图论 - 数理逻辑 - 计算方法 - 近世代数 - 具体数学 - 博弈论 - 运筹学 - 3、专业基础课 课程名称 可能修读学期 计算机导论 1 高级语言程序设计 1或2 数据库原理 2或3 数字电路 2 数据结构 2或3 汇编语言 3或4 计算机组成原理 4或5 操作系统 4或5 计算机网络 5或6 形式语言与自动机 3或4 编译原理 5或6 计算机体系结构 4或5 算法分析与设计 3或4 ==注：== 不同学校对上述课程会有自己的调整，加粗的是我个人认为比较重要的。4、专业选修课，这部分不同学校不同的方向选择会比较多，以下仅供参考： 课程名称 可能修读学期 单片机技术 - 嵌入式开发|-||数学建模|-||数据挖掘|-||机器学习|-||深度学习|-||人工智能|-||网页设计与制作|-||Javaweb开发|-||Python语言程序设计|-||自然语言处理|-||Windows 程序设计|-||计算机图像学|-||数字图像处理|-||网络安全|-||密码学原理与实践|-||并行与分布系统|-||云计算|-||信息检索|-||大数据分析|-||Android 软件开发|-||iOS 移动应用开发 |-||微机系统与接口|-||人机交互技术|-||机器人设计与应用|-||Linux系统基础|-| 后序&emsp;&emsp;计算机专业是一个十分繁杂的专业，它所涉及到的知识与领域，任何一块都值得我们终其一生学习，所以本科开设的这些课程大多也只是带大家了解计算机的这些领域而已，真正想成为大牛，还任重道远。]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之循环链表与双向链表]]></title>
    <url>%2F2019%2F11%2F23%2Fshu-ju-jie-gou-zhi-xun-huan-lian-biao-yu-shuang-xiang-lian-biao%2F</url>
    <content type="text"><![CDATA[0、目录 循环链表 双向链表 双向链表的存储结构 双向链表的插入 双向链表的删除 1、循环链表&emsp;&emsp;循环链表 是另一种形式的链式存储结构。其特点是表中最后一个结点的指针域指向头结点，整个链表形成一个环。由此，从表中任一结点出发均可找到表中其他结点，下图为单链的循环链表。类似地，还可以有多重链的循环链表。&emsp;&emsp;循环链表的操作和单链表基本一致，差别仅在于：当链表遍历的时候，判别当前指针 p 是否指向表尾结点的终止条件不同。在单链表中，判别条件为 p != NULL 或 p -&gt; next != NULL，而循环单链表的判别条件为 p != L 或 p -&gt; next != L。&emsp;&emsp;在某些情况下，若在循环链表中设立尾指针而不设头指针，可使一些操作简化。例如，将两个线性表合并成一个表时，仅需将第一个表的尾指针指向第二个表的第一个结点，第二个表的尾指针指向第一个表的头结点，然后释放第二个表的头结点。当线性表以图（a）的循环链表作存储结构时，这个操作仅需改变两个指针值即可，主要代码段如下，操作的时间复杂度为O(1)，合并后的表如图(b)所示。 p = B->next->next; B->next = A->next; A->next = p; 2、双向链表&emsp;&emsp;双向链表 也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。 2.1 双向链表的存储结构&emsp;&emsp;顾名思义，在双向链表的结点中有两个指针域，一个指向直接的后继，另一个指向直接的前驱。 //-----双向链表的存储结构----- typedef struct DuLNode{ ElemType data; //数据域 struct DuLNode *prior;//直接前驱 struct DuLNode *next; //直接后继 }DuLNode,*DuLinkList; 2.2 双向链表的插入算法描述： Status ListInsert_DuL(DuLinkList &amp;L,int i,ElemType e){ //在带头结点的双向链表L中第i个位置之前插入元素e if(!(p = GetElem_DuL(L,i))) //在L中确定第i个元素的位置指针p return ERROR; //p为NULL时，第i个元素不存在 s = new DuLNode; //生成新结点*s s -> data = e; //将结点*s数据域置为e s -> prior = p -> prior; //将结点*s插入L中，对应图(b)① p -> prior -> next = e; //对于图(b)② s -> next = p; //对于图(b)③ p -> prior = s; //对应图(b)④ return OK; } 2.3 双向链表的删除算法描述： Status ListDelete_DuL(DuLinkList &amp;L,int i){ //删除带头结点的双向链表L中的第i个元素 if(!(p = GetElem_DuL(L,i))) //在L中确定第i个元素的位置指针p return ERROR; //p为NULL时，第i个元素不存在 p -> prior -> next = p -> next; //修改被删结点的前驱结点的后继指针，对于图(a)① p -> next -> prior = p -> prior;//修改被删结点的后继结点的前驱指针，对于图(a)② delete p; //释放被删结点的空间 return OK; }]]></content>
      <categories>
        <category>数据结构与算法分析</category>
      </categories>
      <tags>
        <tag>循环链表</tag>
        <tag>双向链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法之递归与分治]]></title>
    <url>%2F2019%2F11%2F23%2Fsuan-fa-zhi-di-gui-yu-fen-zhi%2F</url>
    <content type="text"><![CDATA[0、目录 算法概念与设计分析 例题 阶乘 Hanoi塔] 整数划分 1、算法概念与设计分析算法总体思想-大事化小小事化了 &emsp;&emsp;对这k个子问题分别求解。如果子问题的规模仍然不够小，则再划分为k个子问题，如此递归的进行下去，直到问题规模足够小，很容易求出其解为止。&emsp;&emsp;将求出的小规模的问题的解合并为一个更大规模的问题的解，自底向上逐步求出原来问题的解。&emsp;&emsp;分治法的设计思想是，将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。&emsp;&emsp;直接或间接地调用自身的算法称为 递归算法。用函数自身给出定义的函数称为 递归函数。递归有两种 直接递归：自己调用自己 间接递归：A调用B，B调用A //直接递归：自己调用自己 A(){ … A(); … } //间接递归：A调用B，B调用A A(){ … B(); … } B(){ … A(); … } &emsp;&emsp;由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。&emsp;&emsp;分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。怎么写递归函数： 相同的事情交给相同的函数做。 当你在写函数A()时，如果又碰到了同样的事情时，就直接调用自己。 已找到递归方程（两边都有同一个函数），可以用递归。如n!、Fibonacci数列等。 没有递归方程的话（例如不是要求算某个数，而是要求做某些事），你要找出分解后小规模问题与原问题的相似之处。如Hanoi塔、全排列; 有时需要利用递归调用、返回的顺序特征。 一个返回值的话，就直接return；多个的话，作为函数的参数。参数中需要改变的量应该采用引用调用，例如&amp;max,&amp;min。 别忘了边界条件—出口。 递归的优缺点：优点： 结构清晰，可读性强，而且容易用数学归纳法来证明算法的正确性，因此它为设计算法、调试程序带来很大方便。缺点： 递归算法的运行效率较低，无论是耗费的计算时间还是占用的存储空间都比非递归算法要多。分治法的适用条件：分治法所能解决的问题一般具有以下几个特征： 该问题的规模缩小到一定的程度就可以容易地解决； 该问题可以分解为若干个规模较小的相同问题 利用该问题分解出的子问题的解可以合并为该问题的解； 该问题所分解出的各个子问题是相互独立的，即子问题之间不重复。 这条特征涉及到分治法的效率，如果各子问题是不独立的，则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然也可用分治法，但一般用动态规划较好。 分治法的基本步骤： divide-and-conquer(P) { if ( | P | &lt;= n0) adhoc(P); //解决小规模的问题 divide P into smaller subinstances P1,P2,...,Pk；//分解问题 for (i=1,i&lt;=k,i++) yi=divide-and-conquer(Pi); //递归的解各子问题 return merge(y1,...,yk); //将各子问题的解合并为原问题的解 } 人们从大量实践中发现，在用分治法设计算法时，最好使子问题的规模大致相同。即将一个问题分成大小相等的k个子问题的处理方法是行之有效的。这种使子问题规模大致相等的做法是出自一种 平衡(balancing)子问题 的思想，它几乎总是比子问题规模不等的做法要好。 分治法的复杂性分析：&emsp;&emsp;一个分治法将规模为n的问题分成k个规模为n／m的子问题去解。设分解阈值n0=1，且adhoc解规模为1的问题耗费1个单位时间。再设将原问题分解为k个子问题以及用merge将k个子问题的解合并为原问题的解需用f(n)个单位时间。用T(n)表示该分治法解规模为|P|=n的问题所需的计算时间，则有：通过迭代法求得方程的解： 2、例题2.1 阶乘例： 阶乘函数&emsp;&emsp;阶乘函数可递归地定义为： 边界条件、出口 递归方程 &emsp;&emsp;边界条件与递归方程是递归函数的二个要素，递归函数只有具备了这两个要素，才能在有限次计算后得出结果。边界条件一般为显式的，例如if()… 递归过程与工作栈： 递归过程在实现时，需要自己调用自己。 每一次递归调用时，需要为过程中使用的参数、局部变量、返回地址等另外分配存储空间。 层层向下递归，退出时的次序正好相反： 递归次序--------------------------------&gt; n! –&gt; (n-1)! –&gt; (n-2)! –&gt; 1! –&gt; 0!=1 &lt;---------------------------------- 返回次序 因此，每层递归调用需分配的空间形成递归工作记录，按后进先出的栈组织存取。 n的阶乘完整代码: #include&lt;stdio.h> int fact (int n) { if(n==1) return 1; else return(n*fact(n-1)); } int main(){ int n; scanf("%d", &amp;n); printf("%d\n",fact(n)); return 0; } 2.2 Hanoi塔例：Hanoi塔问题&emsp;&emsp;设a,b,c是3个塔座。开始时，在塔座a上有一叠共n个圆盘，这些圆盘自下而上，由大到小地叠在一起。各圆盘从小到大编号为1,2,…,n,现要求将塔座a上的这一叠圆盘移到塔座b上，并仍按同样顺序叠置。在移动圆盘时应遵守以下移动规则：规则1：每次只能移动1个圆盘；规则2：任何时刻都不允许将较大的圆盘压在较小的圆盘之上；规则3：在满足移动规则1和2的前提下，可将圆盘移至a,b,c中任一塔座上。==Hanoi塔问题(递归的关键是分解为同结构的小问题)==Hanoi塔问题完整代码: #include &lt;stdio.h> void Hanoi(int n, char A, char B, char C) { if(n==1) { printf("%c->%c\n", A, C); } else { Hanoi(n-1, A, C, B); printf("%c->%c\n", A, C); Hanoi(n-1, B, A, C); } } int main(void) { int n; //n为盘子的个数 scanf("%d", &amp;n); Hanoi(n, '1', '2', '3'); return 0; } 2.3 整数划分例：整数划分问题&emsp;&emsp;将正整数n表示成一系列正整数之和：n=n1+n2+…+nk，其中n1≥n2≥…≥nk≥1，k≥1。正整数n的这种表示称为正整数n的划分。求正整数n的不同划分个数。例如:正整数6有如下11种不同的划分： 6； 5+1； 4+2，4+1+1； 3+3，3+2+1，3+1+1+1； 2+2+2，2+2+1+1，2+1+1+1+1； 1+1+1+1+1+1。 n=n1+n2+…+nk，其中n1≥n2≥…≥nk≥1，k≥1&emsp;&emsp;前面的几个例子中，问题本身都具有比较明显的递归关系，因而容易用递归函数直接求解。&emsp;&emsp;在本例中，如果设p(n)为正整数n的划分数，则难以找到递归关系，因此考虑增加一个自变量：将sum中最大加数n1不大于m的划分个数记作q(n,m)。可以建立q(n,m)的如下递归关系。(1) q(n,1)=1,n ≥ 1;当最大加数n1不大于1时，任何正整数n只有一种划分形式，即(2) q(n,m)=q(n,n),m ≥ n;最大加数n1实际上不能大于n。因此，q(1,m)=1。将sum中最大加数n1 ≤ m的划分个数记作q(n,m)(3) q(n,n)=1+q(n,n-1);正整数n的划分由n1=n的划分和n1≤n-1的划分组成（n1不可能大于n）。q(6,6)=1+q(6,5)(4) q(n,m)=q(n,m-1)+q(n-m,m),n&gt;m&gt;1;正整数n的最大加数n1不大于m的划分由n1=m的划分和n1≤m-1 的划分组成（思路同(3) ）。q(6,3)=q(6,2)+q(6-3,3)q(n-m,m): n=m+n2+…, n2&lt;=n1=mn=n1+n2+…+nk，其中n1≥n2≥…≥nk≥1，k≥1正整数n的划分数p(n)=q(n,n)。整数划分问题完整代码: #include&lt;stdio.h> int q(int n,int m){ if(n==1 || m==1){ return 1; }else if(n > m){ return q(n-m,m)+q(n,m-1); }else if(n &lt; m){ return q(n,n); }else{ return 1+q(n,n-1); } } int main(){ int n; scanf("%d",&amp;n); printf("%d\n",q(n,n)); return 0; }]]></content>
      <categories>
        <category>数据结构与算法分析</category>
      </categories>
      <tags>
        <tag>递归与分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java后端开发系列博客之类与对象（基础篇）]]></title>
    <url>%2F2019%2F11%2F19%2F1-2-java-hou-duan-kai-fa-xi-lie-bo-ke-zhi-lei-yu-dui-xiang-ji-chu-pian%2F</url>
    <content type="text"><![CDATA[类与对象Java作为一种面向对象语言。支持以下基本概念： 多态 继承 封装 抽象 类 对象 实例 方法 重载 本节我们重点研究对象和类的概念。对象： 对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。类： 类是一个模板，它描述一类对象的行为和状态。 1、Java中的对象&emsp;&emsp;现在让我们深入了解什么是对象。看看周围真实的世界，会发现身边有很多对象，车，狗，人等等。所有这些对象都有自己的状态和行为。&emsp;&emsp;拿一条狗来举例，它的状态有：名字、品种、颜色，行为有：叫、摇尾巴和跑。&emsp;&emsp;对比现实对象和软件对象，它们之间十分相似。&emsp;&emsp;软件对象也有状态和行为。软件对象的状态就是属性，行为通过方法体现。&emsp;&emsp;在软件开发中，方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成。 2、Java中的类类可以看成是创建Java对象的模板。 public class Dog{ String breed; int age; String color; void barking(){ } void hungry(){ } void sleeping(){ } } 一个类可以包含以下类型变量： 局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。 成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。 类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。 一个类可以拥有多个方法，在上面的例子中：barking()、hungry()和sleeping()都是Dog类的方法。 3、构造方法&emsp;&emsp;每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。&emsp;&emsp;在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。下面是一个构造方法示例： public class Puppy{ public Puppy(){ } public Puppy(String name){ // 这个构造器仅有一个参数：name } } 4、创建对象对象是根据类创建的。在Java中，使用关键字new来创建一个新的对象。创建对象需要以下三步： 声明：声明一个对象，包括对象名称和对象类型。 实例化：使用关键字new来创建一个对象。 初始化：使用new创建对象时，会调用构造方法初始化对象。 下面是一个创建对象的例子： public class Puppy{ public Puppy(String name){ //这个构造器仅有一个参数：name System.out.println("小狗的名字是 : " + name ); } public static void main(String[] args){ // 下面的语句将创建一个Puppy对象 Puppy myPuppy = new Puppy( "tommy" ); } } /* //运行结果： 小狗的名字是 : tommy */ 5、访问实例变量和方法通过已创建的对象来访问成员变量和成员方法，如下所示： /* 实例化对象 */ Object referenceVariable = new Constructor(); /* 访问类中的变量 */ referenceVariable.variableName; /* 访问类中的方法 */ referenceVariable.methodName(); 6、实例下面的例子展示如何访问实例变量和调用成员方法： public class Puppy{ int puppyAge; public Puppy(String name){ // 这个构造器仅有一个参数：name System.out.println("小狗的名字是 : " + name ); } public void setAge( int age ){ puppyAge = age; } public int getAge( ){ System.out.println("小狗的年龄为 : " + puppyAge ); return puppyAge; } public static void main(String[] args){ /* 创建对象 */ Puppy myPuppy = new Puppy( "tommy" ); /* 通过方法来设定age */ myPuppy.setAge( 2 ); /* 调用另一个方法获取age */ myPuppy.getAge( ); /*你也可以像下面这样访问成员变量 */ System.out.println("变量值 : " + myPuppy.puppyAge ); } } /* //运行结果： 小狗的名字是 : tommy 小狗的年龄为 : 2 变量值 : 2 */ 7、几种特殊类7.1 抽象类&emsp;&emsp;在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。&emsp;&emsp;抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。&emsp;&emsp;由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。&emsp;&emsp;父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。&emsp;&emsp;在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。在Java语言中使用abstract class来定义抽象类。如下实例： /* 文件名 : Employee.java */ public abstract class Employee { private String name; private String address; private int number; public Employee(String name, String address, int number) { System.out.println("Constructing an Employee"); this.name = name; this.address = address; this.number = number; } public double computePay() { System.out.println("Inside Employee computePay"); return 0.0; } public void mailCheck() { System.out.println("Mailing a check to " + this.name + " " + this.address); } public String toString() { return name + " " + address + " " + number; } public String getName() { return name; } public String getAddress() { return address; } public void setAddress(String newAddress) { address = newAddress; } public int getNumber() { return number; } } 抽象类总结规定： 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。 7.2 final类&emsp;&emsp;final为Java中常用的关键字，被final修饰的类不可被继承。&emsp;&emsp;如果将某个类设置为final形式，则类中的所有方法都被隐式设置为final形式，但是final类中的成员变量可以被定义为final或非final形式。 7.3 内部类&emsp;&emsp;在 Java 中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。广泛意义上的内部类一般来说包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类。下面就先来了解一下这四种内部类的用法。7.3.1 成员内部类&emsp;&emsp;成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式： class Circle { double radius = 0; public Circle(double radius) { this.radius = radius; } class Draw { //内部类 public void drawSahpe() { System.out.println("drawshape"); } } } &emsp;&emsp;这样看起来，类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。 class Circle { private double radius = 0; public static int count =1; public Circle(double radius) { this.radius = radius; } class Draw { //内部类 public void drawSahpe() { System.out.println(radius); //外部类的private成员 System.out.println(count); //外部类的静态成员 } } } &emsp;&emsp;不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问： 外部类.this.成员变量外部类.this.成员方法 &emsp;&emsp;虽然成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问： class Circle { private double radius = 0; public Circle(double radius) { this.radius = radius; getDrawInstance().drawSahpe(); //必须先创建成员内部类的对象，再进行访问 } private Draw getDrawInstance() { return new Draw(); } class Draw { //内部类 public void drawSahpe() { System.out.println(radius); //外部类的private成员 } } } &emsp;&emsp;成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下： public class Test { public static void main(String[] args) { //第一种方式： Outter outter = new Outter(); Outter.Inner inner = outter.new Inner(); //必须通过Outter对象来创建 //第二种方式： Outter.Inner inner1 = outter.getInnerInstance(); } } class Outter { private Inner inner = null; public Outter() { } public Inner getInnerInstance() { if(inner == null) inner = new Inner(); return inner; } class Inner { public Inner() { } } } &emsp;&emsp;内部类可以拥有 private 访问权限、protected 访问权限、public 访问权限及包访问权限。比如上面的例子，如果成员内部类 Inner 用 private 修饰，则只能在外部类的内部访问，如果用 public 修饰，则任何地方都能访问；如果用 protected 修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。这一点和外部类有一点不一样，外部类只能被 public 和包访问两种权限修饰。我个人是这么理解的，由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰。7.3.2 局部内部类&emsp;&emsp;局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。 class People{ public People() { } } class Man{ public Man(){ } public People getWoman(){ class Woman extends People{ //局部内部类 int age =0; } return new Woman(); } } 注意: 局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static 修饰符的。7.3.3 匿名内部类&emsp;&emsp;匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。下面这段代码是一段 Android 事件监听代码： scan_bt.setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { // TODO Auto-generated method stub } }); history_bt.setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { // TODO Auto-generated method stub } }); 这段代码为两个按钮设置监听器，这里面就使用了匿名内部类。这段代码中的： new OnClickListener() { @Override public void onClick(View v) { // TODO Auto-generated method stub } } &emsp;&emsp;就是匿名内部类的使用。代码中需要给按钮设置监听器对象，使用匿名内部类能够在实现父类或者接口中的方法情况下同时产生一个相应的对象，但是前提是这个父类或者接口必须先存在才能这样使用。当然像下面这种写法也是可以的，跟上面使用匿名内部类达到效果相同。 private void setListener() { scan_bt.setOnClickListener(new Listener1()); history_bt.setOnClickListener(new Listener2()); } class Listener1 implements View.OnClickListener{ @Override public void onClick(View v) { // TODO Auto-generated method stub } } class Listener2 implements View.OnClickListener{ @Override public void onClick(View v) { // TODO Auto-generated method stub } } &emsp;&emsp;这种写法虽然能达到一样的效果，但是既冗长又难以维护，所以一般使用匿名内部类的方法来编写事件监听代码。同样的，匿名内部类也是不能有访问修饰符和 static 修饰符的。&emsp;&emsp;匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为 Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。7.3.4 静态内部类&emsp;&emsp;静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。 public class Test { public static void main(String[] args) { Outter.Inner inner = new Outter.Inner(); } } class Outter { public Outter() { } static class Inner { public Inner() { } } }]]></content>
      <categories>
        <category>Java后端开发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>类与对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java后端开发系列博客之基础语法（基础篇）]]></title>
    <url>%2F2019%2F11%2F18%2F1-1-java-hou-duan-kai-fa-xi-lie-bo-ke-zhi-ji-chu-yu-fa-ji-chu-pian%2F</url>
    <content type="text"><![CDATA[Java的基础语法 Java简单介绍 基本设计结构 注释 数据类型 标识符和关键字 变量 修饰符 运算符 1、Java的简单介绍&emsp;&emsp;Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。&emsp;&emsp;Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点。Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等。 2、基本设计结构2.1 注释&emsp;&emsp;类似于 C/C++、Java 也支持单行以及多行注释。注释中的字符将被 Java 编译器忽略。 /* * 1.这是一个多行注释的示例 */ // 2.这是单行注释的示例 /* 这个也是单行注释的示例 */ /** 3.文档注释 */ 2.2 数据类型Java 的两大数据类型: 内置数据类型 引用数据类型 &emsp;&emsp;Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。2.2.1：整型 表2-1 Java整型 类型 存储需求 取值范围 默认值 int 4字节 -2147483648(-2^31^)~2147483647(2^31^-1) (正好超过20亿) 0 short 2字节 -32768(-2^15^)~32767(2^15^-1) 0 long 8字节 -9223372036854775808(2^63^)~9223372036854775807(2^63^-1) 0L byte 1字节 -128(2^7^)~127(2^7^-1) 0 2.2.2：浮点型 表2-2 Java浮点型 类型 存储需求 取值范围 默认值 float 4字节 大约&plusmn;3.40282347E+38F(有效位数为6~7为) 0.0f double 8字节 大约&plusmn;1.79769313486231570E+308(有效位数为15位数) 0.0d 2.2.3：字符型 char类型是一个单一的 16 位 Unicode 字符；最小值是 \u0000（即为0）；最大值是 \uffff（即为65,535）；char 数据类型可以储存任何字符；例子：char letter = ‘A’;。 2.2.4：布尔型 boolean数据类型表示一位的信息；只有两个取值：true 和 false；这种类型只作为一种标志来记录 true/false 情况；默认值是 false；例子：boolean one = true。 2.2.5：默认值 //关于默认值的示例 public class Lizi { static boolean bool; static byte by; static char ch; static double d; static float f; static int i; static long l; static short sh; static String str; public static void main(String[] args) { System.out.println("Bool :" + bool); System.out.println("Byte :" + by); System.out.println("Character:" + ch); System.out.println("Double :" + d); System.out.println("Float :" + f); System.out.println("Integer :" + i); System.out.println("Long :" + l); System.out.println("Short :" + sh); System.out.println("String :" + str); } } /* //运行结果： Bool :false Byte :0 Character: Double :0.0 Float :0.0 Integer :0 Long :0 Short :0 String :null */ 注意事项： Java中的默认类型：整数类型是 int 、浮点类型是double 数据范围与字节数不一定相关，例如float数据范围比 long 更加广泛，但是float是4字节，1ong是8字节。 浮点型可能只是一个近似值，并非精确的值。 浮点数当中默认类型是double。如果一定要使用float类型，需要加上一个后缀F。 字符串不是基本类型，而是引用类型。 如果是整数，默认为int类型，如果一定要使用long类型，需要加上一个后缀L。推荐使用大写字母后缀。 2.2.7：引用数据类型 在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。 对象、数组都是引用数据类型。 所有引用类型的默认值都是null。 一个引用变量可以用来引用任何与之兼容的类型。 例子：Site site = new Site(“Runoob”)。 2.2.8：常量&emsp;&emsp;常量在程序运行时是不能被修改的。&emsp;&emsp;在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似： final double PI = 3.1415927; 虽然常量名也可以用小写，但为了便于识别，通常使用大写字母表示常量。2.2.9：转义字符2.2.10：自动类型转换&emsp;&emsp;整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。转换从低级到高级。 低 ————————————&gt; 高byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double 数据类型转换必须满足如下规则： 不能对boolean类型进行类型转换。 不能把对象类型转换成不相关类的对象。 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。 转换过程中可能导致溢出或损失精度。 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入。 2.2.11：强制类型转换 条件是转换的数据类型必须是兼容的。 格式：(type)value type是要强制类型转换后的数据类型 2.3 标识符和关键字2.3.1 标识符&emsp;&emsp;java中所有命名的位置所用的都是标识符。命名规则: 由 字母 数字 _(下划线) ＄ 组成 不能以数字开头 严格区分大小写 大小写视为不同名字 ( java是一种强类型语言 ) 标识符不能用关键字 命名规范: 见名知意即可 不要过长 camel 驼峰原则 包的命名:全部小写 多级包用 . 隔开 例如:teng.xun 类||接口: 每个单词的首字母大写 例如:JingDong 方法||变量: 第一个单词全部小写,第二个单词开始,每个单词首字母大写 taoBao 常量:全部大写 每个单词之间使用 _ 进行分割 GUO_WU_YUAN 2.3.2 关键字:&emsp;&emsp;Java里事先定义的，有特别意义的标识符，有时又叫保留字，还有特别意义的变量。所有的关键字都是小写, IDE中颜色存在不同显示。具体可参考：Java中50个关键字和关键字的意思注： 随着版本的升级，关键字可能会变化。 2.4 变量Java语言支持的变量类型有： 类变量：独立于方法之外的变量，用 static 修饰。 实例变量：独立于方法之外的变量，不过没有 static 修饰。 局部变量：类的方法中的变量。public class Lizi{ static int allClicks=0; // 类变量 String str="hello world"; // 实例变量 public void method(){ int i =0; // 局部变量 } } 2.5 修饰符Java语言提供了很多修饰符，主要分为以下两类： 访问修饰符 非访问修饰符 2.5.1访问控制修饰符&emsp;&emsp;Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。 default (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。 private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类） public : 对所有类可见。使用对象：类、接口、变量、方法 protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。 我们可以通过以下表来说明访问权限：2.5.2 非访问修饰符为了实现一些其他的功能，Java 也提供了许多非访问修饰符。static 修饰符，用来修饰类方法和类变量。final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。abstract 修饰符，用来创建抽象类和抽象方法。synchronized 和 volatile 修饰符，主要用于线程的编程。具体可参考： 菜鸟教程。 2.6 运算符表2-3 算术运算符 操作符 描述 + 加法：相加运算符两侧的值 - 减法：左操作数减去右操作数 * 乘法：相乘操作符两侧的值 / 除法：左操作数除以右操作数 % 取余：左操作数除以右操作数的余数 ++ 自增：操作数的值增加1 – 自减：操作数的值减少1 public class Lizi { public static void main(String[] args) { int a = 10; int b = 20; int c = 25; int d = 25; System.out.println("a + b = " + (a + b) ); System.out.println("a - b = " + (a - b) ); System.out.println("a * b = " + (a * b) ); System.out.println("b / a = " + (b / a) ); System.out.println("b % a = " + (b % a) ); System.out.println("c % a = " + (c % a) ); System.out.println("a++ = " + (a++) ); System.out.println("a-- = " + (a--) ); // 查看 d++ 与 ++d 的不同 System.out.println("d++ = " + (d++) ); System.out.println("++d = " + (++d) ); } } /* //运行结果： a + b = 30 a - b = -10 a * b = 200 b / a = 2 b % a = 0 c % a = 5 a++ = 10 a-- = 11 d++ = 25 ++d = 27 /* 表2-4 关系运算符 操作符 描述 == 检查如果两个操作数的值是否相等，如果相等则条件为真。 != 检查如果两个操作数的值是否相等，如果值不相等则条件为真。 &gt; 检查左操作数的值是否大于右操作数的值，如果是那么条件为真。 &lt; 检查左操作数的值是否小于右操作数的值，如果是那么条件为真。 &gt;= 检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。 &lt;= 检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。 public class Lizi { public static void main(String[] args) { int a = 10; int b = 20; System.out.println("a == b = " + (a == b) ); System.out.println("a != b = " + (a != b) ); System.out.println("a > b = " + (a > b) ); System.out.println("a &lt; b = " + (a &lt; b) ); System.out.println("b >= a = " + (b >= a) ); System.out.println("b &lt;= a = " + (b &lt;= a) ); } } /* //运行结果： a == b = false a != b = true a > b = false a &lt; b = true b >= a = true b &lt;= a = false */ 表2-5 位运算符 操作符 描述 ＆ 如果相对应位都是1，则结果为1，否则为0 &#124; 如果相对应位都是 0，则结果为 0，否则为 1 ^ 如果相对应位值相同，则结果为0，否则为1 ~ 按位取反运算符翻转操作数的每一位，即0变成1，1变成0。 &lt;&lt; 按位左移运算符。左操作数按位左移右操作数指定的位数。 &gt;&gt; 按位右移运算符。左操作数按位右移右操作数指定的位数。 &gt;&gt;&gt; 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 public class Lizi { public static void main(String[] args) { int a = 60; /* 60 = 0011 1100 */ int b = 13; /* 13 = 0000 1101 */ int c = 0; c = a &amp; b; /* 12 = 0000 1100 */ System.out.println("a &amp; b = " + c ); c = a | b; /* 61 = 0011 1101 */ System.out.println("a | b = " + c ); c = a ^ b; /* 49 = 0011 0001 */ System.out.println("a ^ b = " + c ); c = ~a; /*-61 = 1100 0011 */ System.out.println("~a = " + c ); c = a &lt;&lt; 2; /* 240 = 1111 0000 */ System.out.println("a &lt;&lt; 2 = " + c ); c = a >> 2; /* 15 = 1111 */ System.out.println("a >> 2 = " + c ); c = a >>> 2; /* 15 = 0000 1111 */ System.out.println("a >>> 2 = " + c ); } } /* //运行结果： a &amp; b = 12 a | b = 61 a ^ b = 49 ~a = -61 a &lt;&lt; 2 = 240 a >> 2 = 15 a >>> 2 = 15 */ 表2-6 逻辑运算符 操作符 描述 &amp;&amp; 称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。 &#124;&#124; 称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。 ！ 称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。 public class Lizi { public static void main(String[] args) { boolean a = true; boolean b = false; System.out.println("a &amp;&amp; b = " + (a&amp;&amp;b)); System.out.println("a || b = " + (a||b)); System.out.println("!(a &amp;&amp; b) = " + !(a &amp;&amp; b)); } } /* //运行结果： a &amp;&amp; b = false a || b = true !(a &amp;&amp; b) = true */ 注： 当使用与逻辑运算符时，在两个操作数都为true时，结果才为true，但是当得到第一个操作为false时，其结果就必定是false，这时候就不会再判断第二个操作了。或逻辑同理，当得到第一个操作为true时，其结果就必定是true，这时候就不会再判断第二个操作了。 表2-7 赋值运算符 操作符 描述 = 简单的赋值运算符，将右操作数的值赋给左侧操作数 += 加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数 -= 减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数 * = 乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数 / = 除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数 (%)= 取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数 &lt;&lt; = 左移位赋值运算符 &gt;&gt; = 右移位赋值运算符 ＆= 按位与赋值运算符 ^ = 按位异或赋值操作符 &#124;= 按位或赋值操作符 public class Lizi { public static void main(String[] args) { int a = 10; int b = 20; int c = 0; c = a + b; System.out.println("c = a + b = " + c ); c += a ; System.out.println("c += a = " + c ); c -= a ; System.out.println("c -= a = " + c ); c *= a ; System.out.println("c *= a = " + c ); a = 10; c = 15; c /= a ; System.out.println("c /= a = " + c ); a = 10; c = 15; c %= a ; System.out.println("c %= a = " + c ); c &lt;&lt;= 2 ; System.out.println("c &lt;&lt;= 2 = " + c ); c >>= 2 ; System.out.println("c >>= 2 = " + c ); c >>= 2 ; System.out.println("c >>= 2 = " + c ); c &amp;= a ; System.out.println("c &amp;= a = " + c ); c ^= a ; System.out.println("c ^= a = " + c ); c |= a ; System.out.println("c |= a = " + c ); } } /* //运行结果： c = a + b = 30 c += a = 40 c -= a = 30 c *= a = 300 c /= a = 1 c %= a = 5 c &lt;&lt;= 2 = 20 c >>= 2 = 5 c >>= 2 = 1 c &amp;= a = 0 c ^= a = 10 c |= a = 10 */ 条件运算符（?:）&emsp;&emsp;条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。 表达式?值1:值2如果表达式为真 返回值1如果表达式为假 返回值2 variable x = (expression) ? value if true : value if false instanceof 运算符&emsp;&emsp;该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。instanceof运算符使用格式如下： ( Object reference variable ) instanceof (class/interface type) &emsp;&emsp;如果运算符左侧变量所指的对象，是操作符右侧类或接口(class/interface)的一个对象，那么结果为真。Java运算符优先级:&emsp;&emsp;我认为这部分并不重要，实际编程中我们更喜欢用小括号来控制优先级。所以这部分我不做详细说明。大家如果有兴趣则参考：菜鸟教程。]]></content>
      <categories>
        <category>Java后端开发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之88]]></title>
    <url>%2F2019%2F11%2F11%2Fleetcode-shua-ti-ji-lu-zhi-88%2F</url>
    <content type="text"><![CDATA[88、合并两个有序数组给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。说明： 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例： 输入: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 输出: [1,2,2,3,5,6] 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/merge-sorted-array/ 1、C语言代码：int cmpfunc (const void * a, const void * b){ return ( *(int*)a - *(int*)b ); } void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n){ int j = 0; for(int i = m;i &lt; nums1Size;i++){ nums1[i] = nums2[j++]; } qsort(nums1, m+n, sizeof(int), cmpfunc); return nums1; } 解释： 最朴素的解法就是将两个数组合并之后再排序。 知识点回顾： 无。 2、Java代码：class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { // two get pointers for nums1 and nums2 int p1 = m - 1; int p2 = n - 1; // set pointer for nums1 int p = m + n - 1; // while there are still elements to compare while ((p1 >= 0) &amp;&amp; (p2 >= 0)) // compare two elements from nums1 and nums2 // and add the largest one in nums1 nums1[p--] = (nums1[p1] &lt; nums2[p2]) ? nums2[p2--] : nums1[p1--]; // add missing elements from nums2 System.arraycopy(nums2, 0, nums1, 0, p2 + 1); } } 解释： 双指针 / 从后往前。 知识点回顾：1、System中提供了一个native静态方法arraycopy(),可以使用这个方法来实现数组之间的复制。对于一维数组来说，这种复制属性值传递，修改副本不会影响原来的值。对于二维或者一维数组中存放的是对象时，复制结果是一维的引用变量传递给副本的一维数组，修改副本时，会影响原来的数组。 3、Python代码：class Solution: def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None: """ Do not return anything, modify nums1 in-place instead. """ nums1[:] = sorted(nums1[:m]+nums2) 解释： 类似于C语言的求解方式。 知识点回顾： 无。 4、JavaScript代码：/** * @param {number[]} nums1 * @param {number} m * @param {number[]} nums2 * @param {number} n * @return {void} Do not return anything, modify nums1 in-place instead. */ var merge = function(nums1, m, nums2, n) { nums1.splice(m, nums1.length - m, ...nums2.slice(0, n)); nums1 = nums1.sort((a, b) => a - b); }; 解释： 类似于C语言的求解方式。 知识点回顾：1、splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。注释： 该方法会改变原始数组。语法：arrayObject.splice(index,howmany,item1,…..,itemX)index：必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。howmany：必需。要删除的项目数量。如果设置为 0，则不会删除项目。item1, …, itemX：可选。向数组添加的新项目。返回值：包含被删除项目的新数组，如果有的话。说明： splice() 方法可删除从 index 处开始的零个或多个元素，并且用参数列表中声明的一个或多个值来替换那些被删除的元素。如果从 arrayObject 中删除了元素，则返回的是含有被删除的元素的数组。2、slice() 方法可从已有的数组中返回选定的元素。语法：arrayObject.slice(start,end)start：必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。end：可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。返回值：返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。说明： 请注意，该方法并不会修改数组，而是返回一个子数组。如果想删除数组中的一段元素，应该使用方法 Array.splice()。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决eclipse导入工程后出现的乱码问题]]></title>
    <url>%2F2019%2F11%2F11%2Fjie-jue-eclipse-dao-ru-gong-cheng-hou-chu-xian-de-luan-ma-wen-ti%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;eclipse之所以会出现乱码问题是因为eclipse编辑器选择的编码规则是可变的。一般默认都是UTF-8或者GBK，当从外部导入的一个工程时，如果该工程的编码方式与eclipse中设置的编码方式不同，就会产生中文的乱码问题，这其中还有几种情况。（1）如果导入的整个工程的编码方式与eclipse的编码方式有冲突，那么这个工程里所有的中文都是乱码;（2）如果所有工程的编码方式与eclipse工作空间的编码方式有冲突，那么所有的工程里的中文都有可能是乱码。对于eclipse工作空间 ，eclipse会把你改的设置保存在工作空间的设置文件中，对于单个工程的编码方式进行修改，那么eclipse会把编码方式保存在该工程 的.setting文件包里。所以，要避免中文乱码问题有两个原则：（1）避免频繁更换工作空间，最好项目从一开始就在一个工作空间中进行，并且最好设置工作空间的编码方式为你平时最经常使用的或者是公司规定的项目编码方式，这样工程就会使用工作空间的编码方式，避免出现编码不一致的情形；（2）相同类型的文件尽量使用相同的编码方式，可以保证相同类型的文件都能使用一致的编码设置；==解决中文乱码问题可以有以下方案：==（1）修改工作空间的编码方式：&emsp;&emsp;Window-&gt;Preferences-&gt;General-&gt;Workspace-&gt;Text file Encoding&emsp;&emsp;在Others里选择需要的编码方式(如没有则直接输入)，然后保存。（2）修改单个工程的编码方式：&emsp;&emsp;右击工程，在弹出的菜单中选择最后一项“Properties”&emsp;&emsp;在打开的新窗口左边的菜单树中选择 Info（即第一个），然后在右面找到 Text file encoding ，选择 “other”，在下拉框中选择需要的编码方式(如没有则直接输入)。（3）修改一类文件的编码方式：&emsp;&emsp;假设要将js文件编码方式设为UTF-8，则应该&emsp;&emsp;Window-&gt;Preferences-&gt;General-&gt;Content Types&emsp;&emsp;在Content Types中选择JavaScript Source File，在File associations栏中选中*.js,然后在Default Encoding栏中输入UTF-8，单击Update，保存即可。（4）修改单个文件的编码方式：&emsp;&emsp;右击要修改的文件，在弹出的菜单中选择最后一项 “Properties”，在打开的新窗口左边的菜单树中选择 Info（即第一个），然后在右面找到 Text file encoding ，选择 “other”，在下拉框中选择需要的编码方式(如没有则直接输入)。与修改工程编码方式的方法类似。ps：在项目过程中遇到的另外一个乱码问题是因为操作系统的字体文件问题，在某些情况下，eclipse所使用的系统中文字体如果被破坏的话，也会导致中文无法显示的问题。所以，如果在上述设置都无法解决问题的时候，应该要考虑一下系统字体文件的问题。]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之896]]></title>
    <url>%2F2019%2F11%2F08%2Fleetcode-shua-ti-ji-lu-zhi-896%2F</url>
    <content type="text"><![CDATA[896、单调数列如果数组是单调递增或单调递减的，那么它是单调的。如果对于所有 i &lt;= j，A[i] &lt;= A[j]，那么数组 A 是单调递增的。 如果对于所有 i &lt;= j，A[i]&gt; = A[j]，那么数组 A 是单调递减的。当给定的数组 A 是单调数组时返回 true，否则返回 false。示例 1： 输入：[1,2,2,3] 输出：true 示例 2： 输入：[6,5,4,4] 输出：true 示例 3： 输入：[1,3,2] 输出：false 示例 4： 输入：[1,2,4,5] 输出：true 示例 5： 输入：[1,1,1] 输出：true 提示： 1 &lt;= A.length &lt;= 5000 -100000 &lt;= A[i] &lt;= 100000 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/monotonic-array/ 1、C语言代码：bool increasing(int* A,int ASize){ for (int i = 0; i &lt; ASize - 1; ++i) if (A[i] > A[i+1]) return false; return true; } bool decreasing(int* A,int ASize){ for (int i = 0; i &lt; ASize - 1; ++i) if (A[i] &lt; A[i+1]) return false; return true; } bool isMonotonic(int* A, int ASize){ return increasing(A,ASize) || decreasing(A,ASize); } 解释： 如果数组单调递增或单调递减，那么该数组是单调的。由于 a &lt;= b 和 b &lt;= c 暗示着 a &lt;= c，我们只需要检查相邻元素以确定数组是单调递增（或是递减）。我们可以在一次遍历中检查每个属性。要检查数组 A 是否单调递增，我们将检查每个 i 是否对应有 A[i] &lt;= A[i+1]。对单调检查是类似的。 知识点回顾： 无。 2、Java代码：class Solution { public boolean isMonotonic(int[] A) { int store = 0; for (int i = 0; i &lt; A.length - 1; ++i) { int c = Integer.compare(A[i], A[i+1]); if (c != 0) { if (c != store &amp;&amp; store != 0) return false; store = c; } } return true; } } 解释： 要在一次遍历中执行该检查，我们将会处理由 {−1,0,1} 组成的比较流，分别对应 &lt;，==，或 &gt;。例如，对于数组 [1, 2, 2, 3, 0]，我们将会看到数据流 (-1, 0, -1, 1)。跟踪 store，它的值等于所看到的第一个非零比较值（如果存在）。一旦我们看到与之相反的比较值，那么答案就变成了 False。否则，每次比较值都必定在集合 {−1,0} 中或是在 {0,1} 中，此时数组是单调的。 知识点回顾： 无。 3、Python代码：class Solution: def isMonotonic(self, A: List[int]) -> bool: return A == sorted(A) or A==sorted(A)[::-1] 解释： 两次排序比较。 知识点回顾： 无。 4、JavaScript代码：/** * @param {number[]} A * @return {boolean} */ var isMonotonic = function(A) { let up = true, down = true for(let i = 1; i&lt; A.length; i++){ if(A[i]>A[i-1]) down = false if(A[i]&lt;A[i-1]) up = false if(!down &amp;&amp; !up) return false } return true }; 解释： up 单调递增 down单调递减 如果既不是单调递增也不是单调递减(!up &amp;&amp; !down) 返回false。 知识点回顾： 无。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之169]]></title>
    <url>%2F2019%2F11%2F07%2Fleetcode-shua-ti-ji-lu-zhi-169%2F</url>
    <content type="text"><![CDATA[169、求众数给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。你可以假设数组是非空的，并且给定的数组总是存在众数。示例 1: 输入: [3,2,3] 输出: 3 示例 2： 输入: [2,2,1,1,1,2,2] 输出: 2 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/majority-element/ 1、C语言代码：int cmp(const void *a, const void *b){ return *(int*)a - *(int*)b; } int majorityElement(int* nums, int numsSize){ qsort(nums, numsSize, sizeof(nums[0]), cmp); return nums[numsSize/2]; } 解释： 因为题目说众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素，所以排序后中间的数就是众数。 知识点回顾： 无。 2、Java代码：class Solution { public int majorityElement(int[] nums) { Arrays.sort(nums); return nums[nums.length/2]; } } 解释： 类似于C语言的求解思路。 知识点回顾： 无。 3、Python代码：class Solution: def majorityElement(self, nums: List[int]) -> int: return sorted(nums)[len(nums) // 2] 解释： 类似于C语言的求解思路。 知识点回顾： 无。 4、JavaScript代码：/** * @param {number[]} nums * @return {number} */ var majorityElement = function(nums) { return nums.sort()[parseInt(nums.length/2)]; }; 解释： 类似于C语言的求解思路。 知识点回顾：1、parseInt() 函数可解析一个字符串，并返回一个整数。语法：parseInt(string, radix)string：必需。要被解析的字符串。radix：可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。 如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。 如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。返回值：返回解析后的数字。 更多解法： 参考官方题解。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之387]]></title>
    <url>%2F2019%2F11%2F06%2Fleetcode-shua-ti-ji-lu-zhi-387%2F</url>
    <content type="text"><![CDATA[387、字符串中的第一个唯一字符给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。案例： s = &quot;leetcode&quot; 返回 0. s = &quot;loveleetcode&quot;, 返回 2. 注意事项： 您可以假定该字符串只包含小写字母。难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/first-unique-character-in-a-string/ 1、C语言代码：int firstUniqChar(char * s) { int table[26] = {0}; int i, len = strlen(s); for (i = 0; i &lt; len; ++i) table[s[i] - 'a']++; for (i = 0; i &lt; len; ++i) if (1 == table[s[i] - 'a']) return i; return -1; } 解释： 设一标记数组，初始化为0，用来存储字符串中各个字符出现的次数 之后按照字符串的顺序对 table 数组进行遍历，table 中出现的第一个元素为1的所对应的字母就是第一个唯一字符 最后输出其对应的字符串中的下标即可 知识点回顾： 无。 2、Java代码:class Solution { public int firstUniqChar(String s) { HashMap&lt;Character, Integer> count = new HashMap&lt;Character, Integer>(); int n = s.length(); // build hash map : character and how often it appears for (int i = 0; i &lt; n; i++) { char c = s.charAt(i); count.put(c, count.getOrDefault(c, 0) + 1); } // find the index for (int i = 0; i &lt; n; i++) { if (count.get(s.charAt(i)) == 1) return i; } return -1; } } 解释： 类似于C语言的求解思路。 知识点回顾：1、charAt() 方法用于返回指定索引处的字符。索引范围为从 0 到 length() - 1。语法：public char charAt(int index)index – 字符的索引。返回值：返回指定索引处的字符。 3、Python代码：class Solution: def firstUniqChar(self, s: str) -> int: for i in range(len(s)): if s.find(s[i]) == s.rfind(s[i]): return i return -1 解释： find是从左往右搜索，rfind是从右往左搜索，都是返回第一个匹配的下标。如果两者一致，证明这个就是唯一值。 知识点回顾： 无。 4、JavaScript代码：/** * @param {string} s * @return {number} */ var firstUniqChar = function(s) { for(let i in s){ if(s.indexOf(s[i]) === s.lastIndexOf(s[i])){ return i } } return -1; }; 解释： 类似于Python的求解思路。 知识点回顾： 无。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之58]]></title>
    <url>%2F2019%2F11%2F05%2Fleetcode-shua-ti-ji-lu-zhi-58%2F</url>
    <content type="text"><![CDATA[58、最后一个单词的长度给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串，返回其最后一个单词的长度。如果不存在最后一个单词，请返回 0 。说明： 一个单词是指由字母组成，但不包含任何空格的字符串。示例： 输入: &quot;Hello World&quot; 输出: 5 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/length-of-last-word/ 1、C语言代码：int lengthOfLastWord(char * s){ int c = 0; if(strlen(s) == 0) return 0; for(int i = strlen(s) - 1;i >= 0;i--){ if(s[i] != ' ') c++; else{ if(c) break; } } return c; } 解释： 先求字符串的长度，如果是0直接返回，否则从后向前遍历字符串，如果不是’ ‘则计数加1，如果是’ ‘，为了防止字符串最后有空格的情况，需要再加一次判断。计数不为0的时候跳出循环，返回计数。 知识点回顾： 无。 2、Java代码：class Solution { public int lengthOfLastWord(String s) { return s.trim().length() - s.trim().lastIndexOf(" ") - 1; } } 解释： 重复利用Java的方法。 知识点回顾：1、trim() 方法用于删除字符串的头尾空白符。2、lastIndexOf() 方法有以下四种形式： public int lastIndexOf(int ch): 返回指定字符在此字符串中最后一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。 public int lastIndexOf(int ch, int fromIndex): 返返回指定字符在此字符串中最后一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。 public int lastIndexOf(String str): 返回指定字符在此字符串中最后一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。 public int lastIndexOf(String str, int fromIndex): 返回指定字符在此字符串中最后一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。 语法： public int lastIndexOf(int ch) public int lastIndexOf(int ch, int fromIndex) public int lastIndexOf(String str) public int lastIndexOf(String str, int fromIndex) ch – 字符。fromIndex – 开始搜索的索引位置。str – 要搜索的子字符串。返回值：指定子字符串在字符串中第一次出现处的索引值。 3、Python代码：class Solution: def lengthOfLastWord(self, s: str) -> int: return len(s.rstrip().split(" ")[-1]) 解释： 先去掉字符串的最后空格 将字符串按照空格分组 取分组后的最后一项 计算它的长度 知识点回顾：1、Python rstrip() 删除 string 字符串末尾的指定字符（默认为空格）语法：str.rstrip([chars])chars – 指定删除的字符（默认为空格）返回值：返回删除 string 字符串末尾的指定字符后生成的新字符串。2、split() 通过指定分隔符对字符串进行切片，如果第二个参数 num 有指定值，则分割为 num+1 个子字符串。语法：str.split(str=””, num=string.count(str))str – 分隔符，默认为所有的空字符，包括空格、换行(\n)、制表符(\t)等。num – 分割次数。默认为 -1, 即分隔所有。返回值：返回分割后的字符串列表。 4、JavaScript代码：/** * @param {string} s * @return {number} */ var lengthOfLastWord = function(s) { s = s.replace(/(\s*$)/g, "") let arr = s.split(' ') return arr[arr.length -1].length }; 解释： 正则表达式的使用。 知识点回顾：1、replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。该方法不会改变原始字符串。语法：string.replace(searchvalue,newvalue)searchvalue：必须。规定子字符串或要替换的模式的 RegExp 对象。请注意，如果该值是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换为 RegExp 对象。newvalue：必需。一个字符串值。规定了替换文本或生成替换文本的函数。返回值：一个新的字符串，是用 replacement 替换了 regexp 的第一次匹配或所有匹配之后得到的。2、split() 方法用于把一个字符串分割成字符串数组。提示： 如果把空字符串 (“”) 用作 separator，那么 stringObject 中的每个字符之间都会被分割。注意： split() 方法不改变原始字符串。语法：string.split(separator,limit)separator：可选。字符串或正则表达式，从该参数指定的地方分割 string Object。limit：可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。返回值：一个字符串数组。该数组是通过在 separator 指定的边界处将字符串 string Object 分割成子串创建的。返回的数组中的字串不包括 separator 自身。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之1207]]></title>
    <url>%2F2019%2F11%2F04%2Fleetcode-shua-ti-ji-lu-zhi-1207%2F</url>
    <content type="text"><![CDATA[1207、独一无二的出现次数给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。示例 1： 输入：arr = [1,2,2,1,1,3] 输出：true 解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。 示例 2： 输入：arr = [1,2] 输出：false 示例 3： 输入：arr = [-3,0,1,-3,1,1,1,-3,10,0] 输出：true 提示： 1 &lt;= arr.length &lt;= 1000 -1000 &lt;= arr[i] &lt;= 1000 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/unique-number-of-occurrences/ 1、C语言代码：//解法一 bool uniqueOccurrences(int* arr, int arrSize){ int a[2001] = {0},flag = 0; for(int i = 0;i &lt; arrSize;i++){ arr[i] += 1000; a[arr[i]]++; } for(int i = 0;i &lt; 2001;i++){ if(a[i]!=0){ for(int j = i + 1;j &lt; 2001;j++){ if(a[i] == a[j]) flag = 1; } } } if(flag == 0) return true; else return false; } //解法一优化 bool uniqueOccurrences(int* arr, int arrSize){ int times[2001] = {0}; // 保存每个数字出现的次数 for (int i = 0; i &lt; arrSize; i++) times[arr[i] + 1000]++; int cnts[1001] = {0}; // 保存每一种**次数**，有几个数字出现过，一旦发现 >1 立即返回 false for (int i = 0; i &lt; 2001; i++) { if (times[i] != 0) { cnts[times[i]]++; if (cnts[times[i]] > 1) return false; } } return true; } 解释： 因为最多有1000个数，每个数的范围也是在[-1000, 1000]内，就用了最直接的统计，不搞啥排序了，暴力循环几千次耗不了多少时间。出现次数相同的数字大于1个就返回false。 知识点回顾： 无。 2、Java代码：class Solution { public boolean uniqueOccurrences(int[] arr) { int[] times = new int[2001]; for (int i=0; i&lt;arr.length; i++) times[arr[i] + 1000]++; int[] cnts = new int[1001];// 保存每一种次数，有几个数字出现过，一旦发现 >1 立即返回 false for (int i = 0; i&lt;2001; i++) { if (times[i] != 0) { cnts[times[i]]++; if (cnts[times[i]] > 1) return false; } } return true; } } 解释： 类似于C语言的求解思路。 知识点回顾： 无。 3、Python代码：class Solution: def uniqueOccurrences(self, arr: List[int]) -> bool: from collections import Counter c = Counter(arr) return len(set(c.values())) == len(c.values()) 解释： 先用Counter统计词频，然后判断是否出现的次数是否唯一。 知识点回顾： Counter函数用来遍历列表中的所有元素 并将元素出现的次数记录下来。 4、JavaScript代码：/** * @param {number[]} arr * @return {boolean} */ var uniqueOccurrences = function(arr) { let c = {} let e = {} let s = true for(let i = 0;i &lt; arr.length;i++){ if(!c[arr[i]]){ c[arr[i]] = 1 }else{ c[arr[i]] = c[arr[i]] + 1 } } for( let j in c){ if(!e[c[j]]){ e[c[j]] = true }else{ s = false e[c[j]] = false } } return s }; 解释：1.统计数据中各元素出现的次数。2.统计次数值有没相等的。3.默认为true ,当出现次数相同时及为false。 知识点回顾： 无。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之976]]></title>
    <url>%2F2019%2F11%2F02%2Fleetcode-shua-ti-ji-lu-zhi-976%2F</url>
    <content type="text"><![CDATA[976、三角形的最大周长&emsp;&emsp;给定由一些正数（代表长度）组成的数组 A，返回由其中三个长度组成的、面积不为零的三角形的最大周长。&emsp;&emsp;如果不能形成任何面积不为零的三角形，返回 0。示例 1： 输入：[2,1,2] 输出：5 示例 2： 输入：[1,2,1] 输出：0 示例 3： 输入：[3,2,3,4] 输出：10 示例 4： 输入：[3,6,2,3] 输出：8 提示： 3 &lt;= A.length &lt;= 10000 1 &lt;= A[i] &lt;= 10^6 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/largest-perimeter-triangle/ 1、C语言代码:int inc (const void * a,const void *b){ return * (int * )a-* (int *)b; } int largestPerimeter(int* A, int ASize){ qsort(A,ASize, sizeof(int), inc); for(int i = ASize - 3;i >= 0;i--) if(A[i] + A[i+1] > A[i+2]) return (A[i] + A[i+1] + A[i+2]); return 0; } 解释： 不失一般性的，我们假设三角形的边长满足 a≤b≤c。那么这三条边组成三角形的面积非零的充分必要条件是 a+b&gt;c。再假设我们已经知道 c 的长度了，我们没有理由不从数组中选择尽可能大的 a 与 b。因为当且仅当 a+b&gt;c 的时候，它们才能组成一个三角形。 知识点回顾： 无。 2、Java代码:class Solution { public int largestPerimeter(int[] A) { Arrays.sort(A); for (int i = A.length - 3; i >= 0; i--) if (A[i] + A[i+1] > A[i+2]) return A[i] + A[i+1] + A[i+2]; return 0; } } 解释： 类似于C语言的求解思路。 知识点回顾： 无。 3、Python代码：class Solution(object): def largestPerimeter(self, A): A.sort() for i in range(len(A) - 3, -1, -1): if A[i] + A[i+1] > A[i+2]: return A[i] + A[i+1] + A[i+2] return 0 解释： 类似于C语言的求解思路。 知识点回顾： 无。 4、JavaScript代码：/** * @param {number[]} A * @return {number} */ var largestPerimeter = function(A) { A.sort((a,b) => a - b); for(let i = A.length - 3; i >= 0; i--){ if(A[i] + A[i+1] > A[i+2]) return A[i]+A[i+1]+A[i+2]; } return 0; } 解释： 类似于C语言的求解思路。 知识点回顾： 无。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之350]]></title>
    <url>%2F2019%2F11%2F01%2Fleetcode-shua-ti-ji-lu-zhi-350%2F</url>
    <content type="text"><![CDATA[350、两个数组的交集 II给定两个数组，编写一个函数来计算它们的交集。示例 1： 输入: nums1 = [1,2,2,1], nums2 = [2,2] 输出: [2,2] 示例 2： 输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出: [9,4] 说明： 输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。 我们可以不考虑输出结果的顺序。 进阶： 如果给定的数组已经排好序呢？你将如何优化你的算法？ 如果 nums1 的大小比 nums2 小很多，哪种方法更优？ 如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/ 1、C语言代码：/** * Note: The returned array must be malloced, assume caller calls free(). */ int cmp(const void* a, const void* b){ return *(int*)a > *(int*)b; } int* intersect(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){ *returnSize = nums1Size > nums2Size ? nums2Size : nums1Size; int *ans = (int*)malloc(sizeof(int) * (*returnSize)); qsort(nums1, nums1Size, sizeof(int), cmp); qsort(nums2, nums2Size, sizeof(int), cmp); int i = 0, j = 0, k = 0; while(i &lt; nums1Size &amp;&amp; j &lt; nums2Size){ if(nums1[i] > nums2[j]) j++; else if(nums1[i] &lt; nums2[j]) i++; else{ ans[k++] = nums1[i]; i++; j++; } } *returnSize = k; return ans; } 解释： 先排序，然后依次对比2个数组中的元素，相等就放入新创立的数组中。 知识点回顾： 无。 2、Java代码：class Solution { public int[] intersect(int[] nums1, int[] nums2) { HashMap&lt;Integer, Integer> map = new HashMap&lt;>(); List&lt;Integer> list = new ArrayList&lt;>(); for(int num : nums1) { if(!map.containsKey(num)) map.put(num, 1); else map.put(num, map.get(num) + 1); } for(int num : nums2) { if(map.containsKey(num)) { map.put(num, map.get(num) - 1); if(map.get(num) == 0) map.remove(num); list.add(num); } } int[] res = new int[list.size()]; for(int i = 0; i &lt; list.size(); i++) { res[i] = list.get(i); } return res; } } 解释： 使用哈希表记录数组1中的数和其对应频次。遍历数组2，如果当前索引的数在哈希表中存在，则把它丢进结果list中，并把它在哈希表中的频次-1，如果频次为0就移除它。完成遍历后，list中就是我们希望得到的结果。 知识点回顾： 哈希表的相关知识，将在数据结构篇中体现。 3、Python代码：class Solution: def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]: return [nums2.pop(nums2.index(n)) for n in nums1 if n in nums2] 解释： 无。 知识点回顾： 无。 4、JavaScript代码：/** * @param {number[]} nums1 * @param {number[]} nums2 * @return {number[]} */ var intersect = function(nums1, nums2) { return nums1.filter(el => nums2.includes(el) &amp;&amp; nums2.splice(nums2.indexOf(el), 1)) }; 解释： 无。 知识点回顾： 无。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之242]]></title>
    <url>%2F2019%2F10%2F31%2Fleetcode-shua-ti-ji-lu-zhi-242%2F</url>
    <content type="text"><![CDATA[242、有效的字母异位词&emsp;&emsp;给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。示例 1： 输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot; 输出: true 示例 2： 输入: s = &quot;rat&quot;, t = &quot;car&quot; 输出: false 说明：你可以假设字符串只包含小写字母。进阶：如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？ 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/valid-anagram/ 1、C语言代码：//解法一 int inc (const void * a,const void *b){ return * (char * )a-* (char *)b; } bool isAnagram(char * s, char * t){ int c1=0,c2=0; for(int i=0;s[i]!='\0';i++){ c1++; } for(int i=0;t[i]!='\0';i++){ c2++; } qsort(s,c1, sizeof(char), inc); qsort(t,c2, sizeof(char), inc); if(c1!=c2) return false; else for(int i=0;i&lt;=c1;i++){ if(s[i]!=t[i]) return false; } return true; } //解法二 bool isAnagram(char * s, char * t){ int n=strlen(s),m=strlen(t); if(n!=m) return false; int a[26]={0}; for(int i=0;i&lt;n;i++){ a[s[i]-'a']++; a[t[i]-'a']--; } for(int i=0;i&lt;26;i++) if(a[i]!=0) return false; return true; } 解释： 解法一：排序。通过将 s 的字母重新排列成 t 来生成变位词。因此，如果 T 是 S 的变位词，对两个字符串进行排序将产生两个相同的字符串。此外，如果 s 和 t 的长度不同，t 不能是 s 的变位词，我们可以提前返回。解法二：先判断两字符串长度是否相等，若不相等则false，若相等则将两字符串中每种字母的个数做差,若结果为0则true，不为0则false。 知识点回顾： 无。 2、Java代码:class Solution { public boolean isAnagram(String s, String t) { if (s.length() != t.length()) { return false; } int[] counter = new int[26]; for (int i = 0; i &lt; s.length(); i++) { counter[s.charAt(i) - 'a']++; counter[t.charAt(i) - 'a']--; } for (int count : counter) { if (count != 0) { return false; } } return true; } } 解释： 为了检查 t 是否是 s 的重新排列，我们可以计算两个字符串中每个字母的出现次数并进行比较。因为 S 和 T 都只包含 A−Z 的字母，所以一个简单的 26 位计数器表就足够了。 我们需要两个计数器数表进行比较吗？实际上不是，因为我们可以用一个计数器表计算 s 字母的频率，用 t 减少计数器表中的每个字母的计数器，然后检查计数器是否回到零。 知识点回顾： 哈希表的相关知识。 3、Python代码：class Solution: def isAnagram(self, s: str, t: str) -> bool: return sorted(s) == sorted(t) 解释： 类似于C语言的解法一。 知识点回顾： 无。 4、JavaScript代码：/** * @param {string} s * @param {string} t * @return {boolean} */ var isAnagram = function(s, t) { if (s.length !== t.length) return false return s.split('').sort().join('') === t.split('').sort().join('') }; 解释： 类似于C语言的解法一。 知识点回顾： 无。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>哈希表</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习版链表通用模板代码]]></title>
    <url>%2F2019%2F10%2F29%2Fxue-xi-ban-lian-biao-tong-yong-mo-ban-dai-ma%2F</url>
    <content type="text"><![CDATA[#include &lt;stdbool.h> #include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;string.h> typedef struct { // TODO: fill-in real data } data_t; typedef struct list_node { data_t data; struct list_node *next; } list_node_t; list_node_t *glob_list = NULL; bool data_compare(data_t d1, data_t d2) { // TODO: compare d1 with d2, return true if d1 &lt; d2, false otherwise // TODO: if not care about ordering, simply return true return true; } void list_init() { } void list_insert() { data_t data; // TODO: insert codes that produce data here! list_node_t *new_node = (list_node_t*)malloc(sizeof(list_node_t)); new_node->data = data; if (glob_list == NULL) { glob_list = new_node; glob_list->next = NULL; } else if (data_compare(data, glob_list->data)) { new_node->next = glob_list; glob_list = new_node; } else { list_node_t *cur, *prev; cur = glob_list->next; prev = glob_list; while (cur != NULL) { if (data_compare(prev->data, data) &amp;&amp; data_compare(data, cur->data)) { break; } cur = cur->next; prev = prev->next; } prev->next = new_node; new_node->next = cur; } } void list_find() { // TODO input some data for finding list_node_t *cur = glob_list; while (cur != NULL) { // TODO replace `true` with a real condition if (true) { // TODO dump value inside cur->data return; } cur = cur->next; } // TODO replace this if necessary printf("Not found\n"); } void list_delete() { if (glob_list == NULL) { // TODO replace this if necessary printf("The list is empty\n"); } else { // TODO input some data for finding if (glob_list->next == NULL) { // TODO replace `true` with a real condition if (true) { // TODO destroy glob_list->data if necessary free(glob_list); glob_list = NULL; } } else { list_node_t *cur, *prev; prev = glob_list; cur = glob_list->next; while (cur != NULL) { // TODO replace `true` with a real condition if (true) { prev->next = cur->next; // TODO destroy cur->data if necessary free(cur); return; } cur = cur->next; prev = prev->next; } // TODO replace this if necessary printf("Not found.\n"); } } } void list_destroy() { list_node_t *cur = glob_list; while (cur != NULL) { list_node_t *t = cur->next; // TODO destroy cur->data if necessary free(cur); cur = t; } glob_list = NULL; } int main() { // TODO add your transactions here return 0; }]]></content>
      <categories>
        <category>数据结构与算法分析</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之349]]></title>
    <url>%2F2019%2F10%2F29%2Fleetcode-shua-ti-ji-lu-zhi-349%2F</url>
    <content type="text"><![CDATA[349、两个数组的交集给定两个数组，编写一个函数来计算它们的交集。示例 1： 输入: nums1 = [1,2,2,1], nums2 = [2,2] 输出: [2] 示例 2： 输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出: [9,4] 说明： 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/intersection-of-two-arrays/ 1、C语言代码：//解法一 /** * Note: The returned array must be malloced, assume caller calls free(). */ int *intersection(int *nums1, int nums1Size, int *nums2, int nums2Size, int *returnSize){ int a[1000] = { 0 }, b[1000] = { 0 }, *c = (int*)malloc(sizeof(int)*nums1Size), i, max; for (i = max = 0; i &lt; nums1Size; i++){ //建立两哈希表并寻找出最大值 max if (max &lt; nums1[i]) max = nums1[i]; a[nums1[i]] = 1; } for (i = 0; i &lt; nums2Size; i++){ if (max &lt; nums2[i]) max = nums2[i]; b[nums2[i]] = 1; } for (i = *returnSize = 0; i &lt;= max; i++) //遍历哈希表寻找交集 if (a[i] &amp;&amp; b[i]) c[(*returnSize)++] = i; return c; } //解法二 int* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){ int mark[17000]={0}; for(int i=0;i&lt;nums1Size;i++){ mark[nums1[i]]++; } int maxsize=nums1Size>nums2Size?nums2Size:nums1Size; int *c=(int *)malloc(sizeof(int)*maxsize); int k=0; for(int j=0;j&lt;nums2Size;j++){ if(mark[nums2[j]]>0){ c[k++]=nums2[j]; mark[nums2[j]]=0; } } *returnSize=k; return c; } 解释： 解法一：建立两个哈希表，每个哈希表用很大的数组（初始值为 0）表示，遍历数组，用数组元素的值当作哈希表的下标，赋值为 1，这样两个哈希表就用值为 1 的数组元素的下标表示了两数组中存在的数字，遍历两哈希表，在相同下标下值都为 1 的元素即二者的交集，下标便是交集的值，将其存到返回数组中即可。解法二：计数标记。 知识点回顾： 哈希表的相关知识，将在数据结构篇中体现。 2、Java代码：class Solution { public int[] set_intersection(HashSet&lt;Integer> set1, HashSet&lt;Integer> set2) { int [] output = new int[set1.size()]; int idx = 0; for (Integer s : set1) if (set2.contains(s)) output[idx++] = s; return Arrays.copyOf(output, idx); } public int[] intersection(int[] nums1, int[] nums2) { HashSet&lt;Integer> set1 = new HashSet&lt;Integer>(); for (Integer n : nums1) set1.add(n); HashSet&lt;Integer> set2 = new HashSet&lt;Integer>(); for (Integer n : nums2) set2.add(n); if (set1.size() &lt; set2.size()) return set_intersection(set1, set2); else return set_intersection(set2, set1); } } 解释： 其思想是将两个数组转换为集合 set，然后迭代较小的集合检查是否存在在较大集合中。 知识点回顾： 无。 3、Python代码：class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]: return set(nums1) &amp; set(nums2) 解释： 利用set。 知识点回顾： 集合（set）是一个无序的不重复元素序列。 4、JavaScript代码：/** * @param {number[]} nums1 * @param {number[]} nums2 * @return {number[]} */ var intersection = function(nums1, nums2) { return [...new Set(nums1)].filter( item => nums2.includes(item) ) }; 解释： 无。 知识点回顾： 无。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之206]]></title>
    <url>%2F2019%2F10%2F28%2Fleetcode-shua-ti-ji-lu-zhi-206%2F</url>
    <content type="text"><![CDATA[206、反转链表反转一个单链表。示例： 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 进阶：你可以迭代或递归地反转链表。你能否用两种方法解决这道题？难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/reverse-linked-list/ 1、C语言代码：/** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ struct ListNode* reverseList(struct ListNode* head){ struct ListNode *p,*q,*pr; p = head; q = NULL; while(p){ pr = p->next; p->next = q; q = p; p = pr; } return q; } 解释： 迭代法求解，在遍历列表时，将当前节点的 next 指针改为指向前一个元素。由于节点没有引用其上一个节点，因此必须事先存储其前一个元素。在更改引用之前，还需要另一个指针来存储下一个节点。不要忘记在最后返回新的头引用！ 知识点回顾： 链表的相关知识。可参考我的《数据结构之单链表》篇，也可以参考B站视频反转链表。 2、Java代码：/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode reverseList(ListNode head) { if (head == null || head.next == null) return head; ListNode p = reverseList(head.next); head.next.next = head; head.next = null; return p; } } 解释： 递归法求解。 最开始 1 -&gt; 2 -&gt; 3 -&gt; 4 对于head.next.next = head , 当head在 3 时，相当于加了一个4 -&gt; 3 ，形成回环, 即 1 -&gt; 2 -&gt; 3 4 然后 head.next = None, 取消回环，消除了 3 -&gt; 4 1 -&gt; 2 -&gt; 3 &lt;- 4 知识点回顾： 链表的相关知识。 3、Python代码：# Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def reverseList(self, head: ListNode) -> ListNode: p, rev = head, None while p: rev, rev.next, p = p, rev, p.next return rev 解释： 类似于C语言的求解思路。 知识点回顾： 链表的相关知识。 4、JavaScript代码：/** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {ListNode} */ var reverseList = function(head) { let cur = head // 当前节点 let prev = null // 前置节点初始化（head节点无前置节点） while(cur){ let temp = cur.next // 保存当前节点的后置节点 之后递归到下一个节点需要 cur.next = prev prev = cur cur = temp }; return prev }; 解释： 类似于C语言的求解思路。 知识点回顾： 链表的相关知识。 &emsp;&emsp;本文最后给大家推荐一篇博客：图解反转单向链表]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之单链表]]></title>
    <url>%2F2019%2F10%2F27%2Fshu-ju-jie-gou-zhi-dan-lian-biao%2F</url>
    <content type="text"><![CDATA[0、目录 定义 存储表示 基本操作实现 初始化 取值 查找 插入 删除 创建 前插法创建 后插法创建 求表长 遍历 排序 反转 完整代码1、定义&emsp;&emsp;线性表链式存储结构的特点是：用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）。因此，为了表示每个数据元素 ai 与其直接后继数据元素 ai+1 之间的逻辑关系，对数据元素 ai 来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。这两部分信息组成数据元素 ai 的存储映像，称为 结点，它包括两个域：其中存储数据元素信息的域称为 数据域；存储直接后继存储位置的域称为 指针域。指针域中存储的信息称作 指针 或 链。n 个结点（ai（1≤i≤n）的存储映像）链结成一个 _链表_，即为线性表的链式存储结构。又由于此链表的每个结点中只包含一个指针域，故又称 线性链表 或 单链表。2、存储表示//--------单链表的存储结构------- typedef struct LNode{ ElemType data; //结点的数据域 struct LNode *next; //结点的指针域 }LNode,*LinkList; //LinkList为指向结构体LNode的指针类型 3、基本操作实现3.1、初始化3.1.1、初始化算法步骤①生成新结点作为头结点，用头指针L指向头结点。②头结点的指针域置空。3.1.2、初始化算法描述 Status InitList(LinkList &amp;L){ //构造一个空的单链表L L = new LNode; //生成新结点作为头结点，用头指针L指向头结点 L -> next = NULL; //头结点的指针域置空 return OK; } 3.2、取值3.2.1 取值算法步骤①用指针 p 指向首元结点，用 j 做计数器初值赋为1。②从首元结点开始依次顺着链域 next 向下访问，只要指向当前结点的指针 p 不为空，并且没有到达序号为 i 的结点，则循环执行一下操作： p 指向下一个结点； 计数器 j 相应加1。 ③退出循环时，如果指针 p 为空，或者计数器 j 大于 i，说明指定的序号 i 值不合法（i 大于表长 n 或者 i 小于等于0），取值失败返回ERROR；否则取值成功，此时 j = i 时，p 所指的结点就是要找的第 i 个结点，用参数 e 保存当前结点的数据域，返回OK。 3.2.2 取值算法描述Status GetElem(LinkList L,int i,ElemType &amp;e){ //在带头结点的单链表L中根据序号i获取元素的值，用e返回L中第i个数据元素的值 p = L -> next; j = 1; //初始化，p指向首元结点，计数器j初值赋为1 while(p &amp;&amp; j &lt; i){ //顺链域向后扫描，直到p为空或p指向第i个元素 p = p -> next; //p指向下一个结点 j++; //计数器j相应加1 } if(!p || j > i) return ERROR; //i值不合法i>n或i≤0 e = p -> data; //取第i个结点的数据域 return OK; } 3.3、查找3.3.1 查找算法步骤①用指针 p 指向首元结点。②从首元结点开始依次顺着链域 next 向下查找，只要指向当前结点的指针 p 不为空，并且 p 所指结点的数据域不等于给定值 e，则循环执行以下操作：p 指向下一个结点。③返回 p，若查找成功，p 此时即为结点的地址值，若查找失败，p的值即为 NULL。 3.3.2 查找算法描述LNode *LocateElem(LinkList L,ElemType e){ //在带头结点的单链表L中查找值为e的元素 p = L -> next; //初始化，p指向首元结点 while(p &amp;&amp; p -> data != e) //顺链域向后扫描，直到p为空或p所指结点的数据域等于e p = p -> next; //p指向下一个结点 return p; } 3.4、插入3.4.1 插入算法步骤①查找结点 ai-1 并由指针 p 指向该结点。②生成一个新结点 s。③将新结点 s 的数据域置为e。④将新结点 s的指针域指向结点 a。⑤将结点 p 的指针域指向新结点 *s。 3.4.2 插入算法描述Status ListInsert(LinkList &amp;L,int i,ElemType e){ //在带头结点的单链表L中第i个位置插入值为e的新结点 p = L; j = 0; while(p &amp;&amp; (j &lt; i-1)){ //查找第i-1个结点，p指向该结点。 p = p -> next; j++; } if(!p || j > i-1) return ERROR; //i>n+1或者i&lt;1 s = new LNode; //生成新结点*s s -> data = e; //将结点*s的数据域置为e s -> next = p -> next; //将结点*s的指针域指向结点ai p -> next = s; //将结点*p的指针域指向结点*s return OK; } 3.5、删除3.5.1 删除算法步骤①查找结点 ai-1 并由指针 p 指向该结点。②临时保存待删结点 ai 的地址在 q 中，以备释放。③将结点 *p 的指针域指向 ai 的直接后继结点。④释放结点 ai 的空间。 3.5.2 删除算法描述Status ListDelete(LinkList &amp;L, int i){ //在带头结点的单链表L中，删除第i个元素 p = L; j = 0; while((p -> next) &amp;&amp; (j &lt; i-1)){ //查找第i-1个结点，p指向该结点 p = p -> next; j++; } if(!(p -> next) || (j > i-1)) //当i>n或i&lt;1时，删除位置不合理 return ERROR; q = p -> next; //临时保存被删结点的地址以备释放 p -> next = q -> next; //改变删除结点前驱结点的指针域 delete q; //释放删除结点的空间 return OK; } 3.6、创建3.6.1 前插法创建3.6.1.1 前插法创建算法步骤①创建一个只有头结点的空链表。②根据待创建链表包括的元素 n，循环 n 次执行以下操作： 生成一个新结点 *p； 输入元素值赋给新结点 *p 的数据域； 将新结点 *p 插入到头结点之后。 3.6.1.2 前插法创建算法描述void CreateList_H(LinkList &amp;L,int n){ //逆位序输入n个元素的值，建立带表头结点的单链表L L = new LNode; L -> next = NULL; //先建立一个带头结点的空链表 for(int i = 0;i &lt; n;i++){ p = new LNode; //生成新结点*p cin >> p -> data; //输入元素值赋给新结点*p的数据域 p -> next = L ->next; L -> next = p; //将新结点*p插入到头结点之后 } } 3.6.2 后插法创建3.6.2.1 后插法创建算法步骤①创建一个只有头结点的空链表。②尾指针 r 初始化，指向头结点。③根据创建链表包括的元素个数 n，循环 n 次执行以下操作： 生成一个新结点 *p； 输入元素值赋给新结点 *p 的数据域； 将新结点 p 插入到尾结点 r 之后； 尾指针 r 指向新的尾结点 *p。 3.6.2.2 后插法创建算法描述void CreateList_R(LinkList &amp;L,int n){ //正位序输入n个元素的值，建立带表头结点的单链表L L = new LNode; L -> next = NULL; //先建立一个带头结点的空链表 r = L; //尾指针r指向头结点 for(int i = 0;i &lt; n;i++){ p = new LNode; //生成新结点 cin >> p -> data; //输入元素赋给新结点*p的数据域 p -> next = NULL; r -> next = p; //将新结点*p插入尾结点*r之后 r = p; //r指向新的尾结点*p } } 3.7、求表长3.7.1 求表长算法步骤①用指针 p 指向首元结点。②从首元结点开始依次顺着链域 next 向下查找，只要指向当前结点的指针 p 不为空，则循环执行以下操作：c加1。③返回c。 3.7.2 求表长算法描述int ListLength(LinkList L){ //求链表长度 int c = 0; LinkList p = L -> next; while(p != NULL){ c++; p = p -> next; } return c; } 3.8、遍历3.8.1 遍历算法步骤①用指针 p 指向首元结点。②从首元结点开始依次顺着链域 next 向下查找，只要指向当前结点的指针 p 不为空，则循环执行以下操作：输出当前结点的数据域。 3.8.2 遍历算法描述void TraverseList(LinkList L){ //遍历单链表 LinkList p = L -> next; if(p == NULL) printf("单链表为空"); else{ printf("链表内的值分别是:"); while(p != NULL){ printf("%d ",p -> data); p = p -> next; } } printf("\n"); } 3.9、排序3.9.1 排序算法步骤① 节点值交换法，利用了冒泡排序的思想。 3.9.2 排序算法描述void ListSort(LinkList &amp;L) { //冒泡排序 LinkList p, q; for (p = L->next; p != NULL; p = p->next) for (q = p->next; q != NULL; q = q->next) if (p->data > q->data){ int t1 = p->data; p->data = q->data; q->data = t1; } } 3.10、反转3.10.1 反转算法步骤① 首先让头节点与第一个元素节点断开，但是要注意在断开之前需要用p指针指向第一个元素节点来保存第一个元素节点的位置，然后再断开。在这里有一个指针q指向一个指针域为空的节点，这个节点用来做为链表反转后的最后一个节点。②让第二个元素节点的指针从指向第三个元素节点变为指向第一个元素节点，以此类推，直至指针p指向原链表最后一个元素。③p指针指向NULL时，让原头节点的指针域指向原来最后一个元素节点。此时链表倒置已完成。 3.10.2 反转算法描述Status ListReverse(LinkList &amp;L){ //反转链表 LinkList p,q,pr; p = L -> next; q = NULL; L -> next = NULL; while(p){ pr = p->next; p->next = q; q = p; p = pr; } L -> next = q; return OK; } 4、完整代码#include&lt;iostream> using namespace std; #define ERROR 0 #define OK 1 typedef int Status; typedef int ElemType; //我们这把数据元素类型定义为int //--------单链表的存储结构------- typedef struct LNode{ ElemType data; //结点的数据域 struct LNode *next; //结点的指针域 }LNode,*LinkList; //LinkList为指向结构体LNode的指针类型 Status InitList(LinkList &amp;L){ //构造一个空的单链表L L = new LNode; //生成新结点作为头结点，用头指针L指向头结点 L -> next = NULL; //头结点的指针域置空 return OK; } Status GetElem(LinkList L,int i,ElemType &amp;e){ //在带头结点的单链表L中根据序号i获取元素的值，用e返回L中第i个数据元素的值 LinkList p; int j; p = L -> next; j = 1; //初始化，p指向首元结点，计数器j初值赋为1 while(p &amp;&amp; j &lt; i){ //顺链域向后扫描，直到p为空或p指向第i个元素 p = p -> next; //p指向下一个结点 j++; //计数器j相应加1 } if(!p || j > i) return ERROR; //i值不合法i>n或i≤0 e = p -> data; //取第i个结点的数据域 return OK; } LNode *LocateElem(LinkList L,ElemType e){ //在带头结点的单链表L中查找值为e的元素 LinkList p; p = L -> next; //初始化，p指向首元结点 while(p &amp;&amp; p -> data != e) //顺链域向后扫描，直到p为空或p所指结点的数据域等于e p = p -> next; //p指向下一个结点 return p; } Status ListInsert(LinkList &amp;L,int i,ElemType e){ //在带头结点的单链表L中第i个位置插入值为e的新结点 LinkList p; int j; LinkList s; p = L; j = 0; while(p &amp;&amp; (j &lt; i-1)){ //查找第i-1个结点，p指向该结点。 p = p -> next; j++; } if(!p || j > i-1) return ERROR; //i>n+1或者i&lt;1 s = new LNode; //生成新结点*s s -> data = e; //将结点*s的数据域置为e s -> next = p -> next; //将结点*s的指针域指向结点ai p -> next = s; //将结点*p的指针域指向结点*s return OK; } Status ListDelete(LinkList &amp;L, int i){ //在带头结点的单链表L中，删除第i个元素 LinkList p = L,q; int j = 0; while((p -> next) &amp;&amp; (j &lt; i-1)){ //查找第i-1个结点，p指向该结点 p = p -> next; j++; } if(!(p -> next) || (j > i-1)) //当i>n或i&lt;1时，删除位置不合理 return ERROR; q = p -> next; //临时保存被删结点的地址以备释放 p -> next = q -> next; //改变删除结点前驱结点的指针域 delete q; //释放删除结点的空间 return OK; } void CreateList_H(LinkList &amp;L,int n){ //逆位序输入n个元素的值，建立带表头结点的单链表L LinkList p; L = new LNode; L -> next = NULL; //先建立一个带头结点的空链表 printf("请输入%d个数:",n); for(int i = 0;i &lt; n;i++){ p = new LNode; //生成新结点*p cin >> p -> data; //输入元素值赋给新结点*p的数据域 p -> next = L ->next; L -> next = p; //将新结点*p插入到头结点之后 } } void CreateList_R(LinkList &amp;L,int n){ //正位序输入n个元素的值，建立带表头结点的单链表L LinkList r,p; L = new LNode; L -> next = NULL; //先建立一个带头结点的空链表 r = L; //尾指针r指向头结点 printf("请输入%d个数:",n); for(int i = 0;i &lt; n;i++){ p = new LNode; //生成新结点 cin >> p -> data; //输入元素赋给新结点*p的数据域 p -> next = NULL; r -> next = p; //将新结点*p插入尾结点*r之后 r = p; //r指向新的尾结点*p } } void TraverseList(LinkList L){ //遍历单链表 LinkList p = L -> next; if(p == NULL) printf("单链表为空"); else{ printf("链表内的值分别是:"); while(p != NULL){ printf("%d ",p -> data); p = p -> next; } } printf("\n"); } int ListLength(LinkList L){ //求链表长度 int c = 0; LinkList p = L -> next; while(p != NULL){ c++; p = p -> next; } return c; } void ListSort(LinkList &amp;L) { //冒泡排序 LinkList p, q; for (p = L->next; p != NULL; p = p->next) for (q = p->next; q != NULL; q = q->next) if (p->data > q->data){ int t1 = p->data; p->data = q->data; q->data = t1; } } Status ListReverse(LinkList &amp;L){ //反转链表 LinkList p,q,pr; p = L -> next; q = NULL; L -> next = NULL; while(p){ pr = p->next; p->next = q; q = p; p = pr; } L -> next = q; return OK; } int main (void){ //示例main函数 LinkList LA,LB; int e; if(InitList(LA)) printf("初始化单链表成功\n"); CreateList_H(LA,10); TraverseList(LA); CreateList_R(LB,5); TraverseList(LB); printf("单链表的长度为：%d\n",ListLength(LA)); if(GetElem(LA,5,e)) printf("单链表LA序号为i的值为：%d\n",e); if(LocateElem(LA,0)) printf("单链表LA值为0的结点地址为：%d\n",LocateElem(LA,0)); if(ListInsert(LA,1,100)){ printf("插入成功\n"); TraverseList(LA); } ListSort(LA); TraverseList(LA); if(ListDelete(LA,1)){ printf("删除成功\n"); TraverseList(LA); } if(ListReverse(LB)){ printf("反转成功\n"); TraverseList(LB); } return 0; }]]></content>
      <categories>
        <category>数据结构与算法分析</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之顺序表]]></title>
    <url>%2F2019%2F10%2F26%2Fshu-ju-jie-gou-zhi-shun-xu-biao%2F</url>
    <content type="text"><![CDATA[0、目录 定义 存储表示 基本操作实现 初始化 取值 查找 插入 删除 完整代码 1、定义 &emsp;&emsp;线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素，这种表示也称作线性表的顺序存储结构或顺序映像。通常，称这种存储结构的线性表为 顺序表。其特点是，逻辑上相邻的数据元素，其物理次序也是相邻的。 2、存储表示 //-------顺序表的存储结构-------- #define MAXSIZE 100 //顺序表可能达到的最大长度 typedef struct{ ElemType *elem; //存储空间的基地址 int length; //当前长度 }SqList; //顺序表的结构类型为SqList 3、基本操作实现3.1、初始化3.1.1、初始化算法步骤①为顺序表L动态分配一个预定义大小的数组空间，使elem指向这段空间的基地址。②将表当前的长度设为0。 3.1.2、初始化算法描述Status InitList(SqList &amp;L){ //构造一个空的顺序表L L.elem = new ElemType[MAXSIZE]; //为顺序表分配一个大小为MAXSIZE的数组空间 if(!L.elem) exit(OVERFLOW); //存储分配失败退出 L.length = 0; //空表长度为0 return OK; } 3.2、取值3.2.1 取值算法步骤①判断指定的位置序号 i 值是否合理（1≤i≤L.length），若不合理，则返回ERROR。②若 i 值合理，则将第 i 个数据元素L.elem[i-1]赋给参数 e，通过 e 返回第 i 个数据元素的传值。 3.2.2 取值算法描述Status GetElem(SqList L,int i,ElemType &amp;e){ if(i &lt; 1 || i > L.length) return ERROR; //判断i值是否合理，若不合理，返回ERROR e = L.elem[i-1]; //elem[i-1]单元存储第i个数据元素 return OK; } 3.3、查找3.3.1 查找算法步骤①从第一个元素起，依次和 e 相比较，若找到与 e 相等的元素L.elem[i]，则查找成功，返回该元素的序号 i+1。②若查遍整个顺序表都没有找到，则查找失败，返回0。 3.3.2 查找算法描述int LocateElem(SqList L,ElemType e){ //在顺序表L中查找值为e的数据元素，返回其序号 for(int i = 0;i &lt; L.length;i++) if(L.elem[i] == e) return i+1; //查找成功，返回序号i+1 return 0; //查找失败，返回0 } 3.4、插入3.4.1 插入算法步骤①判断插入位置 i 是否合法（1≤i≤n+1），若不合法则返回ERROR。②判断顺序表的存储空间是否已满，若满则返回ERROR。③将第 n 个至第 i 个位置的元素依次向后移动一个位置，空出第 i 个位置（i = n+1时无需移动）。④将要插入的新元素 e 放入第 i 个位置。⑤表长加1。 3.4.2 插入算法描述Status ListInsert(SqList &amp;L,int i,ElemType e){ //在顺序表L中第i个位置之前插入新的元素e，i的合法范围是[1,L.length] if((i &lt; 1) || (i > L.length+1)) return ERROR; //i的值不合法 if(L.length == MAXSIZE) return ERROR; //当前存储空间已满 for(int j = L.length-1;j >= i-1;j--) L.elem[j+1] = L.elem[j]; //插入位置及之后的元素后移 L.elem[i-1] = e; //将新元素e放入第i个位置 L.length++; //表长加1 return OK; } 3.5、删除3.5.1 删除算法步骤①判断删除位置 i 是否合法（1≤i≤n），若不合法则返回ERROR。②将第 i+1 个至第 n 个的元素依次向前移动一个位置（i = n时无需移动）。③表长减1。 3.5.2 删除算法描述Status ListDelete(SqList &amp;L,int i){ //在顺序表L中删除第i个元素，i值的合法范围是[1,L.length] if((i &lt; 1) || (i > L.length)) return ERROR; //i值不合法 for(int j = i;i &lt;= L.length-1;j++) L.elem[j-1] = L.elem[j]; //被删除元素之后的元素前移 L.length--; //表长减1 return OK; } 4、完整代码#include&lt;iostream> using namespace std; #define ERROR 0 #define OK 1 #define OVERFLOW -2 #define MAXSIZE 100 //顺序表可能达到的最大长度 typedef int Status; typedef int ElemType; //我们这把数据元素类型定义为int typedef struct{ ElemType *elem; //存储空间的基地址 int length; //当前长度 }SqList; //顺序表的结构类型为SqList Status InitList(SqList &amp;L){ //构造一个空的顺序表L L.elem = new ElemType[MAXSIZE]; //为顺序表分配一个大小为MAXSIZE的数组空间 if(!L.elem) exit(OVERFLOW); //存储分配失败退出 L.length = 0; //空表长度为0 return OK; } Status GetElem(SqList L,int i,ElemType &amp;e){ if(i &lt; 1 || i > L.length) return ERROR; //判断i值是否合理，若不合理，返回ERROR e = L.elem[i-1]; //elem[i-1]单元存储第i个数据元素 return OK; } int LocateElem(SqList L,ElemType e){ //在顺序表L中查找值为e的数据元素，返回其序号 for(int i = 0;i &lt; L.length;i++) if(L.elem[i] == e) return i+1; //查找成功，返回序号i+1 return 0; //查找失败，返回0 } Status ListInsert(SqList &amp;L,int i,ElemType e){ //在顺序表L中第i个位置之前插入新的元素e，i的合法范围是[1,L.length] if((i &lt; 1) || (i > L.length+1)) return ERROR; //i的值不合法 if(L.length == MAXSIZE) return ERROR; //当前存储空间已满 for(int j = L.length-1;j >= i-1;j--) L.elem[j+1] = L.elem[j]; //插入位置及之后的元素后移 L.elem[i-1] = e; //将新元素e放入第i个位置 L.length++; //表长加1 return OK; } Status ListDelete(SqList &amp;L,int i){ //在顺序表L中删除第i个元素，i值的合法范围是[1,L.length] if((i &lt; 1) || (i > L.length)) return ERROR; //i值不合法 for(int j = i;i &lt;= L.length-1;j++) L.elem[j-1] = L.elem[j]; //被删除元素之后的元素前移 L.length--; //表长减1 return OK; } Status TraverseList(SqList L){ //遍历顺序表 if(L.elem == NULL) printf("顺序表为空"); else for(int j = 0;j &lt;= L.length-1;j++) printf("%d ",L.elem[j]); return OK; } int main(void){ //示例main函数 SqList L; ElemType e; if(InitList(L)) printf("初始化顺序表成功\n"); if(ListInsert(L,1,1)) printf("插入数据成功\n"); ListInsert(L,2,2); ListInsert(L,3,3); ListInsert(L,4,18); TraverseList(L); if(GetElem(L,2,e)) printf("\n取出成功，第i个元素值为：%d\n",e); if(LocateElem(L,1)) printf("取出成功，值为e的元素在第%d个\n",LocateElem(L,1)); if(ListDelete(L,4)) printf("删除数据成功\n"); TraverseList(L); return 0; }]]></content>
      <categories>
        <category>数据结构与算法分析</category>
      </categories>
      <tags>
        <tag>顺序表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之1046]]></title>
    <url>%2F2019%2F10%2F16%2Fleetcode-shua-ti-ji-lu-zhi-1046%2F</url>
    <content type="text"><![CDATA[1046、最后一块石头的重量有一堆石头，每块石头的重量都是正整数。每一回合，从中选出两块最重的石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下： 如果 x == y，那么两块石头都会被完全粉碎； 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。 最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。提示： 1 &lt;= stones.length &lt;= 30 1 &lt;= stones[i] &lt;= 1000 题目难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/last-stone-weight/ 1、C语言代码:int comp(const void*a,const void*b){ //用来做比较的函数。 return *(int*)a-*(int*)b; } int lastStoneWeight(int* stones, int stonesSize){ while(stonesSize > 1){ qsort(stones,stonesSize,sizeof(int),comp);//调用qsort排序 stones[stonesSize-2] = stones[stonesSize-1] - stones[stonesSize-2]; stonesSize--; } return stones[0]; } 解释： 当石头的个数大于1时候，进入循环，先排序，再将最重的2颗相减，总个数减一。 知识点回顾： 无。 2、Java代码:class Solution { public static int lastStoneWeight(int[] stones){ int c = stones.length; while(c > 1){ Arrays.sort(stones); stones[c-2] = stones[c-1] - stones[c-2]; c--; } return stones[0]; } } 解释： 类似于C语言的思路。 知识点回顾： stones.length得到的是一个final类型的变量，所以不能自减。 3、Python代码：class Solution: def lastStoneWeight(self, stones: List[int]) -> int: while len(stones) > 1: y = max(stones) stones.remove(y) x = max(stones) stones.remove(x) stones.append(y - x) return stones[0] 解释： 移除2个最重的，加入他们2个的差，一直循环。 知识点回顾： 无。 4、JavaScript代码：/** * @param {number[]} stones * @return {number} */ var lastStoneWeight = function(stones) { let c = stones.length while (c > 1) { stones.sort((a, b) => a - b) stones[c-2] = stones[c-1] - stones[c-2]; c--; } return stones[0] }; 解释： 类似于C语言的求解思路。 知识点回顾： 无。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之283]]></title>
    <url>%2F2019%2F10%2F15%2Fleetcode-shua-ti-ji-lu-zhi-283%2F</url>
    <content type="text"><![CDATA[283. 移动零&emsp;&emsp;给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。示例 1： 输入: [0,1,0,3,12] 输出: [1,3,12,0,0] 说明: 1、必须在原数组上操作，不能拷贝额外的数组。 2、尽量减少操作次数。 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/move-zeroes/ 1、C语言代码：void moveZeroes(int* nums, int numsSize){ int c = 0; //计入0的个数 for(int i = 0;i &lt; numsSize;i++){ if(nums[i] == 0) c++; } for(int i = 0;i &lt; numsSize;i++){ if(c == 0) break; if(nums[i] == 0){ for(int j = i ; j &lt; numsSize-1;j++) nums[j] = nums[j+1]; nums[numsSize-1] = 0; c--; i--; //回溯 } } } 解释： 首先计入0的个数，再次遍历的时候，当0的个数为0时，说明移动结束了，就break，当数组中出现0时，把后面的数字都往前移一位，然后在最后一位上补上0，0的个数减一，为了防止有多个0相邻的情况，需要将i减一，回溯。 知识点回顾： 无。 2、Java代码:class Solution { public void moveZeroes(int[] nums) { int j = 0; for (int i = 0; i &lt; nums.length; i++) { if (nums[i] != 0) { if(i != j) { nums[j] = nums[i]; nums[i] = 0; } j++; } } } } 解释： 定义两个指针i,j，然后遍历数组，i跟j同时往前走，当遇到0时j停下，i继续往前走。当nums[i]不为0时则将num[i]的元素赋给j的位置，j++,nums[i]被赋值为0，在i等于j的情况下，如果num[i]不为0，将num[i]的元素赋给j的位置其实就是自己赋值给自己，所以可以加一个判断条件，i不等j的时候才替换0。 知识点回顾： 无。 3、Python代码：class Solution: def moveZeroes(self, nums: List[int]) -> None: """ Do not return anything, modify nums in-place instead. """ for i in nums[:]: if i==0: nums.append(0) nums.remove(0) 解释： 遍历整个数组，遇0删除，在列表最后添加0。 知识点回顾：1、append() 方法用于在列表末尾添加新的对象。语法：list.append(obj)obj – 添加到列表末尾的对象。返回值：该方法无返回值，但是会修改原来的列表。2、remove() 函数用于移除列表中某个值的第一个匹配项。语法：list.remove(obj)obj – 列表中要移除的对象。返回值：该方法没有返回值但是会移除列表中的某个值的第一个匹配项。 4、JavaScript代码：/** * @param {number[]} nums * @return {void} Do not return anything, modify nums in-place instead. */ var moveZeroes = function(nums) { let nonZeroNums = nums.filter(e => e != 0) nums.forEach((e,i) => nums[i] = i &lt; nonZeroNums.length ? nonZeroNums[i] : 0 ) }; 解释： 最终需要的结果是非零位置保持原顺序，为零位置移动到最后。因此只需要先把原数组中的0移除，再补足移除后的0的位置。 知识点回顾： 无。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之389]]></title>
    <url>%2F2019%2F10%2F14%2Fleetcode-shua-ti-ji-lu-zhi-389%2F</url>
    <content type="text"><![CDATA[389. 找不同&emsp;&emsp;给定两个字符串 s 和 t，它们只包含小写字母。&emsp;&emsp;字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。&emsp;&emsp;请找出在 t 中被添加的字母。示例 1： 输入： s = &quot;abcd&quot; t = &quot;abcde&quot; 输出： e 解释： &#39;e&#39; 是那个被添加的字母。 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/find-the-difference/ 1、C语言代码：char findTheDifference(char * s, char * t){ int ss = 0 , tt = 0; for(int i = 0;s[i] != '\0';i++){ ss += s[i]; //求字符串s的ASCII和 } for(int j = 0;t[j] != '\0';j++){ tt += t[j]; //求字符串t的ASCII和 } return (tt - ss); } 解释： 分别求2个字符串的ASCII码值的和，差值即为被添加的字母。 知识点回顾： 无。 2、Java代码:class Solution { public static char findTheDifference(String s, String t) { int result = 0; for (Character c : s.toCharArray()) { result^=c; } for (Character c : t.toCharArray()) { result^=c; } return (char)result; } } 解释： 运用位运算，两个同样的值异或的结果为 0。对两个字符串中的所有字符进行异或，得到的结果就是被添加的字符。 知识点回顾：1、Character 类用于对单个字符进行操作。Character 类在对象中包装一个基本类型 char 的值。2、toCharArray() 方法将字符串转换为字符数组。 3、Python代码：class Solution: def findTheDifference(self, s: str, t: str) -> str: for i in s: t = t.replace(i,'',1) return t 解释： 遍历一遍s，对s中的每一个字符，用replace函数在t中找到并删除，返回t，replace() 第三个参数代表最大替换次数。 知识点回顾：1、replace() 方法把字符串中的 old（旧字符串） 替换成 new(新字符串)，如果指定第三个参数max，则替换不超过 max 次。语法：str.replace(old, new[, max])old – 将被替换的子字符串。new – 新字符串，用于替换old子字符串。max – 可选字符串, 替换不超过 max 次。返回值：返回字符串中的 old（旧字符串） 替换成 new(新字符串)后生成的新字符串，如果指定第三个参数max，则替换不超过 max 次。 4、JavaScript代码：/** * @param {string} s * @param {string} t * @return {character} */ var findTheDifference = function(s, t) { for(let item of s){ t = t.replace(item, '') } return t }; 解释： 类似于Python的求解思路。 知识点回顾：1、replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。语法：string.replace(searchvalue,newvalue)searchvalue：必须。规定子字符串或要替换的模式的 RegExp 对象。请注意，如果该值是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换为 RegExp 对象。newvalue：必需。一个字符串值。规定了替换文本或生成替换文本的函数。返回值：一个新的字符串，是用 replacement 替换了 regexp 的第一次匹配或所有匹配之后得到的。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之461]]></title>
    <url>%2F2019%2F10%2F13%2Fleetcode-shua-ti-ji-lu-zhi-461%2F</url>
    <content type="text"><![CDATA[461、汉明距离&emsp;&emsp;两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。&emsp;&emsp;给出两个整数 x 和 y，计算它们之间的汉明距离。注意：0 ≤ x, y &lt; 2^31示例1： 示例: 输入: x = 1, y = 4 输出: 2 解释: 1 (0 0 0 1) 4 (0 1 0 0) ↑ ↑ 上面的箭头指出了对应二进制位不同的位置。 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/hamming-distance/ 1、C语言代码：int hammingDistance(int x, int y){ int n = x ^ y; int count = 0; while(n != 0){ count ++; n = n &amp; (n-1); } return count; } 解释： 先将两个数异或运算得到n，那么n里面1的个数就是结果，如果n不为0，那么n至少有一位是1。如果n减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1。其余所有位将不会受到影响。这样右边这部分的&amp;运算结果就为0，然后循环。 知识点回顾： 位运算的相关知识。 2、Java代码：class Solution { public int hammingDistance(int x, int y) { //bitCount 数出整数二进制下 1 的个数 //1^0 = 1 ,0^1 =1 ,0^0 = 0 ,1^1 = 0 return Integer.bitCount(x^y); } } 解释： 数出整数二进制下 1 的个数。 知识点回顾： Integer.bitCount()方法用于统计二进制中1的个数。 3、Python代码：class Solution: def hammingDistance(self, x: int, y: int) -> int: return bin(x^y).count('1') 解释： 类似于Java的求解思路。 知识点回顾：1、bin() 返回一个整数 int 或者长整数 long int 的二进制表示。语法：bin(x)x – int 或者 long int 数字返回值：字符串。2、count() 方法用于统计字符串里某个字符出现的次数。可选参数为在字符串搜索的开始与结束位置。语法：str.count(sub, start= 0,end=len(string))sub – 搜索的子字符串start – 字符串开始搜索的位置。默认为第一个字符,第一个字符索引值为0。end – 字符串中结束搜索的位置。字符中第一个字符的索引为 0。默认为字符串的最后一个位置。返回值：该方法返回子字符串在字符串中出现的次数。 4、JavaScript代码：/** * @param {number} x * @param {number} y * @return {number} */ var hammingDistance = function(x, y) { let ans = 0 while (x !== 0 || y !== 0) { if ((x &amp; 1) !== (y &amp; 1)) { ans++ } x >>= 1 y >>= 1 } return ans }; 解释： 遍历两个数值，位数不相同那么 +1。 知识点回顾： 位运算的相关知识。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之231]]></title>
    <url>%2F2019%2F09%2F11%2Fleetcode-shua-ti-ji-lu-zhi-231%2F</url>
    <content type="text"><![CDATA[231、2的幂&emsp;&emsp;给定一个整数，编写一个函数来判断它是否是 2 的幂次方。示例 1： 输入: 1 输出: true 解释: 2^0 = 1 示例 2： 输入: 16 输出: true 解释: 2^4 = 16 示例 3： 输入: 218 输出: false 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/power-of-two/ 1、C语言代码：bool isPowerOfTwo(int n){ return n > 0 &amp;&amp; (n &amp; (n - 1)) == 0; } 解释： 若 n=2x 且 x 为自然数（即 n 为 2 的幂），则一定满足以下条件：1、恒有 n &amp; (n - 1) == 0，这是因为：&emsp;&emsp;- n 二进制最高位为 1，其余所有位为 0；&emsp;&emsp;- n−1 二进制最高位为 0，其余所有位为 1；2、一定满足 n &gt; 0。 因此，通过 n &gt; 0 且 n &amp; (n - 1) == 0 即可判定是否满足 n=2x 。 知识点回顾： 位运算的使用。 2、Java代码:class Solution { public boolean isPowerOfTwo(int n) { return n > 0 &amp;&amp; (n &amp; (n - 1)) == 0; } } 解释： 类似于C语言的求解思路。 知识点回顾： 位运算的使用。 3、Python代码：class Solution: def isPowerOfTwo(self, n: int) -> bool: return n > 0 and n &amp; (n - 1) == 0 解释： 类似于C语言的求解思路。 知识点回顾： 位运算的使用。 4、JavaScript代码：/** * @param {number} n * @return {boolean} */ var isPowerOfTwo = function(n) { return n > 0 &amp;&amp; (n &amp; (n - 1)) == 0; }; 解释： 类似于C语言的求解思路。 知识点回顾： 位运算的使用。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之633]]></title>
    <url>%2F2019%2F09%2F10%2Fleetcode-shua-ti-ji-lu-zhi-633%2F</url>
    <content type="text"><![CDATA[633、平方数之和&emsp;&emsp;给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c。示例 1： 输入: 5 输出: True 解释: 1 * 1 + 2 * 2 = 5 示例 2： 输入: 3 输出: False 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/sum-of-square-numbers/ 1、C语言代码：bool judgeSquareSum(int c) { long i = 0, j = (int) sqrt(c), tmp; while (i &lt;= j) { tmp = i * i + j * j - c; if (tmp == 0) return true; if (tmp > 0) j = j - 1; else i = i + 1; } return false; } 解释： 令a = 0，b = 根号c + 1，在a &lt;= b 前提下，如果a方+b方小于c，则将a++，大于则将b++，等于直接返回true，当不满足a &lt;= b时，则说明没有满足的组合，返回false。 知识点回顾： 双指针技巧的使用。 2、Java代码:class Solution { public boolean judgeSquareSum(int c) { //StrictMath.sqrt() 开平方 //StrictMath.pow(left,2)速度还不如left*left int left = 0, right = (int) StrictMath.sqrt(c); while (left &lt;= right) { int sum = left * left + right * right; if (sum &lt; c) left++; else if (sum > c) right--; else return true; } return false; } } 解释： 类似于C语言的求解思路。 知识点回顾： 双指针技巧的使用。 3、Python代码：class Solution: def judgeSquareSum(self, c: int) -> bool: j=int(math.sqrt(c)) i=0 while i &lt;=j: if c==i*i+j*j: return True elif i*i+j*j>c: j=j-1 else: i=i+1 解释： 类似于C语言的求解思路。 知识点回顾： 双指针技巧的使用。 4、JavaScript代码：/** * @param {number} c * @return {boolean} */ var judgeSquareSum = function(c) { const flag = Math.sqrt(0.5) * Math.sqrt(c) for(let a = 0;a &lt;= flag; a++){ const b = Math.sqrt(c - a*a) if(parseInt(b) === b){ return true } } return false }; 解释： 首先这道题的题干可以分解为 x^2 + y^2 = r^2 (c = r^2, 因此缩小循环范围至[0,r])。 这个方程明显是一个圆的方程，因为x&gt;=0,y&gt;=0 所以循环范围为第一象限的四分之一圆弧。 由图可知（没有画图，自行脑补吧），该圆弧由y = x这个方程分为上下对称的两部分，因此，若上半部分存在整数解，下半部分定然存在，反之。 最后循环范围可以缩小到八分之一圆弧，即[0, 0.5^-1]这个区间。 剩下的就是遍历这八分之一圆弧上面是否有整数解析 。 知识点回顾： 无。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之326]]></title>
    <url>%2F2019%2F09%2F09%2Fleetcode-shua-ti-ji-lu-zhi-326%2F</url>
    <content type="text"><![CDATA[326、3的幂&emsp;&emsp;给定一个整数，写一个函数来判断它是否是 3 的幂次方。示例 1： 输入: 27 输出: true 示例 2： 输入: 0 输出: false 示例 3： 输入: 9 输出: true 示例 4： 输入: 45 输出: false 进阶： 你能不使用循环或者递归来完成本题吗？ 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/power-of-three/ 1、C语言代码：bool isPowerOfThree(int n){ if (n &lt; 1) return false; while (n % 3 == 0) n /= 3; return n == 1; } 解释： 找出数字 n 是否是数字 b 的幂的一个简单方法是，n%3 只要余数为 0，就一直将 n 除以 b。因此，应该可以将 n 除以 b x 次，每次都有 0 的余数，最终结果是 1。 知识点回顾： 无。 2、Java代码:class Solution { public boolean isPowerOfThree(int n) { return n > 0 &amp;&amp; 1162261467 % n == 0; } } 解释： 通过查看相关解析，发现了这个解法，用到了数论的知识，3的幂次的质因子只有3，而所给出的n如果也是3的幂次，故而题目中所给整数范围内最大的3的幂次的因子只能是3的幂次，1162261467是3的19次幂，是整数范围内最大的3的幂次。 知识点回顾： 无。 3、Python代码：class Solution: def isPowerOfThree(self, n: int) -> bool: return n > 0 and 3 ** round(math.log(n, 3)) == n 解释： 用数学公式求解，math.log 函数得到的数据可能不够精确，可以使用 round 取整。 知识点回顾： 无。 4、JavaScript代码：/** * @param {number} n * @return {boolean} */ var isPowerOfThree = function(n) { return /^10*$/.test(n.toString(3)); }; 解释： 对于10进制数来说，10的n次幂表达为10，100，100。对于2进制数来说，2的n次幂的二进制表达为 10,100,100。3进制同理。 知识点回顾：1、正则表达式的相关知识。2、toString()：数字的字符串表示。例如，当 radix 为 2 时，NumberObject 会被转换为二进制值表示的字符串。语法：number.toString(radix)radix：可选。规定表示数字的基数，是 2 ~ 36 之间的整数。若省略该参数，则使用基数 10。但是要注意，如果该参数是 10 以外的其他值，则 ECMAScript 标准允许实现返回任意值。 2 - 数字以二进制值显示 8 - 数字以八进制值显示 16 - 数字以十六进制值显示 返回值：把数字转换为字符串。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之367]]></title>
    <url>%2F2019%2F09%2F08%2Fleetcode-shua-ti-ji-lu-zhi-367%2F</url>
    <content type="text"><![CDATA[367、有效的完全平方数&emsp;&emsp;给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。&emsp;&emsp;说明：不要使用任何内置的库函数，如 sqrt。示例 1： 输入：16 输出：True 示例 2： 输入：14 输出：False 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/valid-perfect-square/ 1、C语言代码：bool isPerfectSquare(int num){ for(long i = 0;i &lt;= 46340;i++){ if(num == i * i) return true; } return false; } 解释： 暴力求解，这里也可以改成whlie。 知识点回顾： 无。 2、Java代码:class Solution { public boolean isPerfectSquare(int num) { //解法：数学定理(1 + 3 + 5 + ... + (2n - 1) = n ^ 2) int i = 1; while(num > 0) { num -= i; i += 2; } return num == 0; } } 解释： 运用数学知识求解。 知识点回顾： 无。 3、Python代码：class Solution: def isPerfectSquare(self, num: int) -> bool: if num &lt;= 4: return num == 1 or num == 4 l, r = 0, num while l &lt; r: mid = (l+r) // 2 tmp = mid * mid if tmp == num: return True elif tmp &lt; num: l = mid + 1 else: r = mid return False 解释： 二分法求解。 知识点回顾： 无 4、JavaScript代码：/** * @param {number} num * @return {boolean} */ var isPerfectSquare = function(num) { if(num == 1) return true; let cur = parseInt(num/2); while(!(cur*cur&lt;=num&amp;&amp;(cur+1)*(cur+1)>num)){ cur = parseInt(cur-(cur*cur-num)/(2*cur)) } return cur*cur == num; }; 解释： 牛顿迭代法求解。 知识点回顾： 无。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之268]]></title>
    <url>%2F2019%2F09%2F07%2Fleetcode-shua-ti-ji-lu-zhi-268%2F</url>
    <content type="text"><![CDATA[268、缺失数字&emsp;&emsp;给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。示例 1： 输入: [3,0,1] 输出: 2 示例 2： 输入: [9,6,4,2,3,5,7,0,1] 输出: 8 说明： 你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现? 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/missing-number/ 1、C语言代码：int cmp(const void *a,const void *b){ return *(int *)a-*(int *)b;//这是从小到大排序，若是从大到小改成： return *(int *)b-*(int *)a; } int missingNumber(int* nums, int numsSize){ qsort(nums,numsSize,sizeof(nums[0]),cmp);//(数组，需要排序的数字个数，单个数字所占内存大小，比较函数） for(int i = 0;i &lt; numsSize;i++){ if(nums[i] != i) return i; } return; } 解释： 首先我们对数组进行排序，我们可以在线性时间内扫描这个数组，第一个不等于下标的数字，为缺失的数字。 知识点回顾： 无。 2、Java代码:class Solution { public int missingNumber(int[] nums) { int result = 0; for (int i = 1; i &lt;= nums.length; i++) { result += i - nums[i-1]; } return result; } } 解释： 解法：这个题可以这么来理解，求0…n的序列的集合中缺失的某个数字，按照计算运算的方法，求0…n的序列的和，减去数组中所有的元素，得到，的解答就是缺失的数字。用一个for循环从1…n，循环里的第一步是求和，第二步是取出数组中i-1的元素自减，最后的结果就是缺失的元素。 知识点回顾： 无。 3、Python代码：class Solution: def missingNumber(self, nums: List[int]) -> int: return len(nums)*(len(nums)+1)//2 - sum(nums) 解释： 类似于Java的求解思路。 知识点回顾： 无。 4、JavaScript代码：/** * @param {number[]} nums * @return {number} */ var missingNumber = function(nums) { let res = nums.length; for (let i = 0; i &lt; nums.length; i++) { res = res ^ i ^ nums[i]; } return res; }; 解释： 由于异或运算（XOR）满足结合律，并且对一个数进行两次完全相同的异或运算会得到原来的数，因此我们可以通过异或运算找到缺失的数字。我们知道数组中有 n 个数，并且缺失的数在 [0..n] 中。因此我们可以先得到 [0..n] 的异或值，再将结果对数组中的每一个数进行一次异或运算。未缺失的数在 [0..n] 和数组中各出现一次，因此异或后得到 0。而缺失的数字只在 [0..n] 中出现了一次，在数组中没有出现，因此最终的异或结果即为这个缺失的数字。 知识点回顾： 位运算的相关知识。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之26]]></title>
    <url>%2F2019%2F09%2F06%2Fleetcode-shua-ti-ji-lu-zhi-26%2F</url>
    <content type="text"><![CDATA[26、删除排序数组中的重复项&emsp;&emsp;给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。&emsp;&emsp;不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。示例 1： 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2： 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。 说明：为什么返回数值是整数，但输出的答案是数组呢?请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。你可以想象内部操作如下： // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i &lt; len; i++) { print(nums[i]); } 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/ 1、C语言代码:int removeDuplicates(int* nums, int numsSize){ for(int i = 0;i &lt; numsSize - 1;i++){ if(nums[i] == nums[i+1]){ for(int j = i;j &lt; numsSize - 1;j++){ nums[j] = nums[j+1]; } numsSize--; i--; } } return numsSize; } 解释： 顺序循环数组，临近2个数字相同时，将后面一个数字往前移一位，numsSize减1，为了防止有3个以上的相同的数字的相邻，则需要i减1，但是这个方法的时间复杂度较高。 知识点回顾： 无。 2、Java代码:class Solution { public int removeDuplicates(int[] nums) { if (nums.length == 0) return 0; int i = 0; for (int j = 1; j &lt; nums.length; j++) { if (nums[j] != nums[i]) { i++; nums[i] = nums[j]; } } return i + 1; } } 解释： 方法：双指针法，数组完成排序后，我们可以放置两个指针 i 和 j，其中 i 是慢指针，而 j 是快指针。只要 nums[i]=nums[j]，我们就增加 j 以跳过重复项。当我们遇到 nums[j]≠nums[i] 时，跳过重复项的运行已经结束，因此我们必须把它（nums[j]）的值复制到 nums[i+1]。然后递增 i，接着我们将再次重复相同的过程，直到 j 到达数组的末尾为止。 知识点回顾： 无。 3、Python代码：class Solution: def removeDuplicates(self, nums: List[int]) -> int: flag = 0 # 定义一个指针变量 for num in nums: # 遍历数组 if nums[flag] != num: # 若指针指向的元素与当前遍历数组的元素不同 flag += 1 # 指针后移一位 nums[flag] = num # 修改数组，将不同的元素占用重复元素的位置 # 若相同则指针不动，数组继续往后遍历 # 注意考虑数组为空的情况（flag初始值为0，由于要求数组长度，故需要加1） return len(nums) and flag + 1 解释： 类似Java的求解思路。 知识点回顾： 无。 4、JavaScript代码：/** * @param {number[]} nums * @return {number} */ var removeDuplicates = function (nums) { var len = 1; for (var i = 1; i &lt; nums.length; i++) if (nums[i] != nums[i-1]) nums[len++] = nums[i]; return len }; 解释： 类似于Java的求解思路。 知识点回顾： 无。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之1089]]></title>
    <url>%2F2019%2F09%2F05%2Fleetcode-shua-ti-ji-lu-zhi-1089%2F</url>
    <content type="text"><![CDATA[1089、复写零&emsp;&emsp;给你一个长度固定的整数数组 arr，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。&emsp;&emsp;注意：请不要在超过该数组长度的位置写入元素。&emsp;&emsp;要求：请对输入的数组 就地 进行上述修改，不要从函数返回任何东西。示例 1： 输入：[1,0,2,3,0,4,5,0] 输出：null 解释：调用函数后，输入的数组将被修改为：[1,0,0,2,3,0,0,4] 示例 2： 输入：[1,2,3] 输出：null 解释：调用函数后，输入的数组将被修改为：[1,2,3] 提示： 1 &lt;= arr.length &lt;= 10000 0 &lt;= arr[i] &lt;= 9 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/duplicate-zeros/ 1、C语言代码：void duplicateZeros(int* arr, int arrSize){ for(int i = 0;i &lt; arrSize;i++){ if(arr[i] == 0){ for(int j = arrSize - 1;j > i;j--){ arr[j] = arr[j-1]; } i++; } } } 解释： 顺序循环数组，遇见0时，就从后往前把0之后的数组往后移一位，由于这个0也移动了，所以实现了复写的目标，但是再下一次循环时，要跳过这个复写的0，所以i要自增1。 知识点回顾： 无。 2、Java代码：class Solution { public void duplicateZeros(int[] arr) { for(int k = 0; k &lt; arr.length-1; k++){ if(arr[k] == 0){ for(int j=arr.length-1; j > k ; j--){ arr[j] = arr[j-1]; } k++; } } } } 解释： 类似于C语言的求解思路。 知识点回顾： 无。 3、Python代码：class Solution: def duplicateZeros(self, arr: List[int]) -> None: """ Do not return anything, modify arr in-place instead. """ n = len(arr) i = 0 while i &lt; n: if arr[i] == 0: arr.insert(i, 0) arr.pop() i += 2 else: i += 1 解释： 类似于C语言的求解思路。 知识点回顾：1、insert() 函数用于将指定对象插入列表的指定位置。语法：list.insert(index, obj)index：对象 obj 需要插入的索引位置。obj：要插入列表中的对象。返回值：该方法没有返回值，但会在列表指定位置插入对象。2、pop() 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值。语法：list.pop([index=-1])index：可选参数，要移除列表元素的索引值，不能超过列表总长度，默认为 index=-1，删除最后一个列表值。返回值：该方法返回从列表中移除的元素对象。 4、JavaScript代码：/** * @param {number[]} arr * @return {void} Do not return anything, modify arr in-place instead. */ var duplicateZeros = function(arr) { let len = arr.length; for (let i = 0; i &lt; len; i++) { if (arr[i] === 0) { arr.splice(i, 0, 0); i++; } } arr.length = len; }; 解释： 类似于C语言的求解思路。 知识点回顾：1、splice() 方法用于添加或删除数组中的元素。注意：这种方法会改变原始数组。语法：array.splice(index,howmany,item1,…..,itemX)index：必需。规定从何处添加/删除元素。该参数是开始插入和（或）删除的数组元素的下标，必须是数字。howmany：可选。规定应该删除多少元素。必须是数字，但可以是 “0”。如果未规定此参数，则删除从 index 开始到原数组结尾的所有元素。item1, …, itemX：可选。要添加到数组的新元素。返回值：如果从 arrayObject 中删除了元素，则返回的是含有被删除的元素的数组。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之69]]></title>
    <url>%2F2019%2F09%2F04%2Fleetcode-shua-ti-ji-lu-zhi-69%2F</url>
    <content type="text"><![CDATA[69、X的平方根&emsp;&emsp;实现 int sqrt(int x) 函数。&emsp;&emsp;计算并返回 x 的平方根，其中 x 是非负整数。&emsp;&emsp;由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。示例 1： 输入: 4 输出: 2 示例 2： 输入: 8 输出: 2 说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/sqrtx/ 1、C语言代码：int mySqrt(int x){ return sqrt(x); } 解释： 直接使用内置函数求解。 知识点回顾： 无。 2、Java代码：class Solution { public int mySqrt(int x) { return (int)Math.sqrt(x); } } 解释： 直接使用内置函数求解。 知识点回顾： 无。 3、Python代码：class Solution: def mySqrt(self, x: int) -> int: return int(x**0.5) 解释： 直接开方。 知识点回顾： 无。 4、JavaScript代码：/** * @param {number} x * @return {number} */ var mySqrt = function(x) { return parseInt(Math.sqrt(x)); }; 解释： 直接使用内置函数求解。 知识点回顾： 无。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之485]]></title>
    <url>%2F2019%2F09%2F03%2Fleetcode-shua-ti-ji-lu-zhi-485%2F</url>
    <content type="text"><![CDATA[485、最大连续1的个数&emsp;&emsp;给定一个二进制数组， 计算其中最大连续1的个数。示例 1： 输入: [1,1,0,1,1,1] 输出: 3 解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3. 注意： 输入的数组只包含 0 和1。 输入数组的长度是正整数，且不超过 10,000。 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/max-consecutive-ones/ 1、C语言代码：int findMaxConsecutiveOnes(int* nums, int numsSize) { int count = 0,max = 0; for(int i = 0;i &lt; numsSize;i++){ if(nums[i] == 1) count++; else count = 0; if(count > max) max = count; } return max; } 解释： 顺序遍历数组，遇见1就累加，遇见0就重新开始计算，并且对比之前的count，求最大值。 知识点回顾： 无。 2、Java代码：class Solution { public int findMaxConsecutiveOnes(int[] nums) { int res = 0, num = 0; for(int i = 0;i &lt; nums.length;i++){ if(nums[i] == 1) num++; else{ res = num > res ? num:res; num = 0; } } return res > num ? res:num; } } 解释： 顺序遍历,在 nums 数组不为 1 处，统计连续 1 的最大值。 知识点回顾： 无。 3、Python代码：class Solution: def findMaxConsecutiveOnes(self, nums: List[int]) -> int: return len(max(''.join(map(str, nums)).split('0'))) 解释： 重复利用Python的内置函数。 知识点回顾： 无。 4、JavaScript代码：/** * @param {number[]} nums * @return {number} */ var findMaxConsecutiveOnes = function(nums) { var n = m = 0; for (var i=0; i&lt;nums.length; i++) { if (nums[i] !== 1) { n = m > n ? m : n; m = 0; } else { m++; } } n = m > n ? m : n; return n }; 解释： 类似于C语言的思路。 知识点回顾： 无。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之217]]></title>
    <url>%2F2019%2F09%2F02%2Fleetcode-shua-ti-ji-lu-zhi-217%2F</url>
    <content type="text"><![CDATA[217、存在重复元素&emsp;&emsp;给定一个整数数组，判断是否存在重复元素。&emsp;&emsp;如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。示例 1： 输入: [1,2,3,1] 输出: true 示例 2： 输入: [1,2,3,4] 输出: false 示例 3： 输入: [1,1,1,3,3,4,3,2,4,2] 输出: true 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/contains-duplicate/ 1、C语言代码：int cmp(const void *a,const void *b) { return *(int *)a-*(int *)b;//这是从小到大排序，若是从大到小改成： return *(int *)b-*(int *)a; } bool containsDuplicate(int* nums, int numsSize){ qsort(nums,numsSize,sizeof(nums[0]),cmp);//(数组，需要排序的数字个数，单个数字所占内存大小，比较函数） for(int i = 0;i &lt; numsSize - 1;i++){ if(nums[i] == nums[i+1]) return true; } return false; } 解释： 本题最容易想到的就是暴力求解，双重循环判断数组中有没有相同的数，但在本题中，这种方法会超时，于是想到先排序，再循环数组判断有没有相邻的数相等，有则返回true，否则返回false。 知识点回顾： 关于C语言排序函数的使用。 2、Java代码：class Solution { public boolean containsDuplicate(int[] nums) { Set&lt;Integer> set = new HashSet&lt;>(nums.length); for (int x: nums) { if (set.contains(x)) return true; set.add(x); } return false; } } 解释： 方法：哈希表，利用支持快速搜索和插入操作的动态数据结构。使用搜索时间更快的数据结构将加快整个算法的速度。有许多数据结构常用作动态集合,如二进制搜索树和哈希表。这里我们需要的操作是 search 和 insert。对于平衡二叉搜索树（Java 中的 TreeSet 或 TreeMap），search 和 insert 的时间复杂度均为 O(logn)。对于哈希表（Java 中的 HashSet 或 HashMap），search 和 insert 的平均时间复杂度为 O(1)。因此，通过使用哈希表，我们可以达到在线性时间复杂度解决问题。 知识点回顾： 哈希表的相关知识，将在数据结构篇中详细描述。 3、Python代码：class Solution: def containsDuplicate(self, nums: List[int]) -> bool: return len(nums) != len(set(nums)) 解释： 利用Python的特性直接判断。 知识点回顾： 集合（set）是一个无序的不重复元素序列。 4、JavaScript代码：/** * @param {number[]} nums * @return {boolean} */ var containsDuplicate = function(nums) { return new Set(nums).size &lt; nums.length; }; 解释： 类似于Python的求解思路。 知识点回顾： 无。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>哈希表</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之961]]></title>
    <url>%2F2019%2F09%2F01%2Fleetcode-shua-ti-ji-lu-zhi-961%2F</url>
    <content type="text"><![CDATA[961、重复 N 次的元素&emsp;&emsp;在大小为 2N 的数组 A 中有 N+1 个不同的元素，其中有一个元素重复了 N 次。&emsp;&emsp;返回重复了 N 次的那个元素。示例 1： 输入：[1,2,3,3] 输出：3 示例 2： 输入：[2,1,2,5,3,2] 输出：2 示例 3： 输入：[5,1,5,2,5,3,5,4] 输出：5 提示： 4 &lt;= A.length &lt;= 10000 0 &lt;= A[i] &lt; 10000 A.length 为偶数 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array/ 1、C语言代码：int repeatedNTimes(int* A, int ASize){ for(int i = 0;i &lt; ASize - 1;i++){ for(int j = i + 1; j &lt; ASize;j++){ if(A[i] == A[j]) return A[i]; } } return; } 解释： 循环遍历数组，有元素重复出现的就一定是答案。 知识点回顾： 无。 2、Java代码：class Solution { public int repeatedNTimes(int[] A) { for (int k = 1; k &lt;= 3; ++k) for (int i = 0; i &lt; A.length - k; ++i) if (A[i] == A[i+k]) return A[i]; throw null; } } 解释： 一旦找到一个重复元素，那么一定就是答案。我们称这个答案为主要元素。考虑所有长度为 4 的子序列，在子序列中一定至少含有两个主要元素。这是因为：长度为 2 的子序列中都是主要元素，或者；每个长度为 2 的子序列都恰好含有 1 个主要元素，这意味着长度为 4 的子序列一定含有 2 个主要元素。因此，只需要比较所有距离为 1，2 或者 3 的邻居元素即可。 知识点回顾： 无。 3、Python代码：class Solution: def repeatedNTimes(self, A: List[int]) -> int: for i in A: if A.count(i)>=2: return i 解释： 循环遍历数组，有元素出现超过2次的就一定是答案。 知识点回顾： 无。 4、JavaScript代码：/** * @param {number[]} A * @return {number} */ var repeatedNTimes = function(A) { let hash = new Map() for(num of A) { if(hash.has(num)) { return num } else { hash.set(num, 1) } } }; 解释： 数组大小2N，一共 N+1 个元素，目标元素出现N次，说明其他元素只出现一次。创建一个空的哈希表，遍历数组，如果当前元素出现2次，该元素为目标元素。 知识点回顾：1、方法has() 返回一个bool值，用来表明map 中是否存在指定元素。语法：myMap.has(key);key：必填. 用来检测是否存在指定元素的键值。返回值：如果指定元素存在于Map中，则返回true。其他情况返回false。2、set() 方法为 Map 对象添加或更新一个指定了键（key）和值（value）的（新）键值对。语法：myMap.set(key, value);key：要添加至相应 Map 对象的元素的键。value：要添加至相应 Map 对象的元素的值。返回值：Map 对象。3、for…of 语句创建一个循环来迭代可迭代的对象。在 ES6 中引入的 for…of 循环，以替代 for…in 和 forEach() ，并支持新的迭代协议。for…of 允许你遍历 Arrays（数组）, Strings（字符串）, Maps（映射）, Sets（集合）等可迭代的数据结构等。语法： for (variable of iterable) { statement } variable：每个迭代的属性值被分配给该变量。iterable：一个具有可枚举属性并且可以迭代的对象。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之657]]></title>
    <url>%2F2019%2F08%2F31%2Fleetcode-shua-ti-ji-lu-zhi-657%2F</url>
    <content type="text"><![CDATA[657、机器人能否返回原点&emsp;&emsp;在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 (0, 0) 处结束。&emsp;&emsp;移动顺序由字符串表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 R（右），L（左），U（上）和 D（下）。如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。&emsp;&emsp;注意：机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。示例 1： 输入: &quot;UD&quot; 输出: true 解释：机器人向上移动一次，然后向下移动一次。所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 true。 示例 2： 输入: &quot;LL&quot; 输出: false 解释：机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的距离。我们返回 false，因为它在移动结束时没有返回原点。 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/robot-return-to-origin/ 1、C语言代码:bool judgeCircle(char * moves){ int r = 0,l = 0,u = 0, d =0; for(int i =0 ;moves[i] !='\0';i++){ if(moves[i] == 'R') r++; if(moves[i] == 'L') l++; if(moves[i] == 'U') u++; if(moves[i] == 'D') d++; } if(r==l&amp;&amp;u==d) return true; return false; } 解释： 统计各个字符的数量，‘R’和‘L’对比，‘U’和‘D’对比。都相等返回true，否则返回false。 知识点回顾： 无。 2、Java代码:class Solution { public boolean judgeCircle(String moves) { int x = 0, y = 0; for (char c : moves.toCharArray()) { if ('R' == c) x++; else if ('L' == c) x--; else if ('U' == c) y++; else y--; } return x == 0 &amp;&amp; y == 0; } } 解释： 假设原点的笛卡尔坐标为(x,y)=(0,0)，”L””R”，则改变X轴数值，”U””D”，则改变Y轴数值，最后看所在的坐标是不是(0,0)就好了。 知识点回顾：1、toCharArray() 方法将字符串转换为字符数组。语法：public char[] toCharArray()返回值：字符数组。 3、Python代码：class Solution: def judgeCircle(self, moves: str) -> bool: return (moves.count('U') == moves.count('D')) and (moves.count('L')== moves.count('R')) 解释： 判断左右移动的次数和上下移动的次数是否相等。 知识点回顾： 无。 4、JavaScript代码：/** * @param {string} moves * @return {boolean} */ var judgeCircle = function(moves) { return moves.split('L').length === moves.split('R').length &amp;&amp; moves.split('U').length === moves.split('D').length }; 解释： 判断左右移动的次数和上下移动的次数是否相等（即 L.count === R.count &amp;&amp; U.count === D.count） 知识点回顾：1、split() 方法用于把一个字符串分割成字符串数组。提示： 如果把空字符串 (“”) 用作 separator，那么 stringObject 中的每个字符之间都会被分割。注意： split() 方法不改变原始字符串。语法：string.split(separator,limit)separator：可选。字符串或正则表达式，从该参数指定的地方分割 string Object。limit：可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。返回值：一个字符串数组。该数组是通过在 separator 指定的边界处将字符串 string Object 分割成子串创建的。返回的数组中的字串不包括 separator 自身。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之434]]></title>
    <url>%2F2019%2F08%2F30%2Fleetcode-shua-ti-ji-lu-zhi-434%2F</url>
    <content type="text"><![CDATA[434、字符串中的单词数统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。请注意，你可以假定字符串里不包括任何不可打印的字符。示例 1： 输入: &quot;Hello, my name is John&quot; 输出: 5 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/number-of-segments-in-a-string/ 1、C语言代码:int countSegments(char* s) { int count = 0; for(int i = 1;i &lt;= strlen(s);i++) if((s[i] == ' ' || s[i] == '\0') &amp;&amp; s[i-1] != ' ') count++; return count; } 解释： 这道题的题目描述，不是统计单词的数量，而是统计连续的不是空格的字符的数量。 知识点回顾： 无。 2、Java代码:class Solution { public int countSegments(String s) { int segmentCount = 0; for (int i = 0; i &lt; s.length(); i++) { if ((i == 0 || s.charAt(i-1) == ' ') &amp;&amp; s.charAt(i) != ' ') { segmentCount++; } } return segmentCount; } } 解释： 计算单词的数量，就等同于计数单词开始的下标个数。因此，只需要定义好下标的条件，就可以遍历整个字符串，检测每个下标。定义如下：若该下标前为空格（或者为初始下标），且自身不为空格，则其为单词开始的下标。该条件可以以常数时间检测。最后，返回满足条件的下标个数。 知识点回顾：1、charAt() 方法用于返回指定索引处的字符。索引范围为从 0 到 length() - 1。语法：public char charAt(int index)index：字符的索引。返回值：返回指定索引处的字符。 3、Python代码：class Solution: def countSegments(self, s: str) -> int: return len(s.split()) 解释： 使用语言内置函数。 知识点回顾：1、split() 通过指定分隔符对字符串进行切片，如果参数 num 有指定值，则分隔 num+1 个子字符串。语法：str.split(str=””, num=string.count(str))str：分隔符，默认为所有的空字符，包括空格、换行(\n)、制表符(\t)等。num：分割次数。默认为 -1, 即分隔所有。返回值：返回分割后的字符串列表。 4、JavaScript代码：/** * @param {string} s * @return {number} */ var countSegments = function(s) { let str = s.split(' ') let r = 0 for (let i = 0; i &lt; str.length; i++) { if (str[i] !== '') { r++ } } return r }; 解释： 利用split()分割字符串，再遍历字符串数组。 知识点回顾：1、split() 方法用于把一个字符串分割成字符串数组。提示： 如果把空字符串 (“”) 用作 separator，那么 stringObject 中的每个字符之间都会被分割。注意： split() 方法不改变原始字符串。语法：string.split(separator,limit)separator：可选。字符串或正则表达式，从该参数指定的地方分割 string Object。limit：可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。返回值：一个字符串数组。该数组是通过在 separator 指定的边界处将字符串 string Object 分割成子串创建的。返回的数组中的字串不包括 separator 自身。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之520]]></title>
    <url>%2F2019%2F08%2F29%2Fleetcode-shua-ti-ji-lu-zhi-520%2F</url>
    <content type="text"><![CDATA[520、检测大写字母给定一个单词，你需要判断单词的大写使用是否正确。我们定义，在以下情况时，单词的大写用法是正确的：&emsp;&emsp;1、全部字母都是大写，比如”USA”。&emsp;&emsp;2、单词中所有字母都不是大写，比如”leetcode”。&emsp;&emsp;3、如果单词不只含有一个字母，只有首字母大写， 比如 “Google”。否则，我们定义这个单词没有正确使用大写字母。示例 1： 输入: &quot;USA&quot; 输出: True 示例 2： 输入: &quot;FlaG&quot; 输出: False 注意： 输入是由大写和小写拉丁字母组成的非空单词。难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/detect-capital/ 1、C语言代码:bool detectCapitalUse(char * word){ int c = 0,d = 0; if(word[0] >= 'A' &amp;&amp; word[0] &lt;= 'Z'){ for(int i = 1;word[i] != '\0';i++){ if(word[i] >= 'a' &amp;&amp; word[i] &lt;= 'z') c++; else d++; } if(c == 0 || d == 0) return true; else return false; } else{ for(int i = 1;word[i] != '\0';i++){ if(word[i] >= 'A' &amp;&amp; word[i] &lt;='Z') return false; } } return true; } 解释： 分情况讨论，当第一个字母是大写的时候，循环遍历剩下的字母，并且记录大小写字母的个数，如果只有大写字母或者只有小写字母则返回true，否则返回false。当第一个字母是小写的时候，循环遍历剩下的字母，只要存在大写的字母就返回false，否则返回true。 知识点回顾： 无。 2、Java代码:class Solution { public boolean detectCapitalUse(String word) { int sum = 0; for (int i = 0; i &lt; word.length(); i++) { if (word.charAt(i) >= 'A' &amp;&amp; word.charAt(i) &lt;= 'Z') { sum++; } } if (sum &lt; word.length() &amp;&amp; sum > 1) { return false; } else if (sum == 1) { return word.charAt(0) >= 'A' &amp;&amp; word.charAt(0) &lt;= 'Z'; } return true; } } 解释： 统计大写的个数sum，根据个数判断：① sum = 0, true② sum =1, 只有第一个字母为大写时为true③ 1 &lt; sum &lt; n, false④ sum等于数组长度，true 知识点回顾：1、charAt() 方法用于返回指定索引处的字符。索引范围为从 0 到 length() - 1。语法：public char charAt(int index)index：字符的索引。返回值：返回指定索引处的字符。 3、Python代码：class Solution: def detectCapitalUse(self, word: str) -> bool: return word.isupper() or word.islower() or word.istitle() 解释： 如果word全大写或者全小写或者只有首字母大写则返回true。否则返回false。 知识点回顾：1、isupper() 方法检测字符串中所有的字母是否都为大写。语法：str.isupper()返回值：如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False。2、islower() 方法检测字符串是否由小写字母组成。语法：str.islower()返回值：如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False。3、istitle() 方法检测字符串中所有的单词拼写首字母是否为大写，且其他字母为小写。语法：str.istitle()返回值：如果字符串中所有的单词拼写首字母是否为大写，且其他字母为小写则返回 True，否则返回 False。 4、JavaScript代码：/** * @param {string} word * @return {boolean} */ var detectCapitalUse = function(word) { if(word.toUpperCase() === word) return true; // 全部大写 for(let i = 1; i &lt; word.length; i++) { // word[i].charCodeAt(0) >= 65 &amp;&amp; word[i].charCodeAt(0) &lt;= 90 这个是大写字母 if(word[i].charCodeAt(0) &lt;= 90) { // 一个单词只有大小写字母 判断小于90就好了 return false; } } return true; }; 解释： 先判断全部大写，从第二个字母开始循环，有大写字母就返回false，循环到最后返回true。 知识点回顾：1、toUpperCase() 方法用于把字符串转换为大写。语法：string.toUpperCase()2、charCodeAt() 方法可返回指定位置的字符的 Unicode 编码。字符串中第一个字符的位置为 0， 第二个字符位置为 1，以此类推。语法：string.charCodeAt(index)index：必需。表示字符串中某个位置的数字，即字符在字符串中的下标。返回值：返回在指定的位置的字符的 Unicode 编码。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之551]]></title>
    <url>%2F2019%2F08%2F29%2Fleetcode-shua-ti-ji-lu-zhi-551%2F</url>
    <content type="text"><![CDATA[551、学生出勤记录 I给定一个字符串来代表一个学生的出勤记录，这个记录仅包含以下三个字符：&emsp;&emsp;1、’A’ : Absent，缺勤&emsp;&emsp;2、’L’ : Late，迟到&emsp;&emsp;3、’P’ : Present，到场如果一个学生的出勤记录中不超过一个’A’(缺勤)并且不超过两个连续的’L’(迟到),那么这个学生会被奖赏。你需要根据这个学生的出勤记录判断他是否会被奖赏。示例 1： 输入: &quot;PPALLP&quot; 输出: True 示例 2： 输入: &quot;PPALLL&quot; 输出: False 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/student-attendance-record-i/ 1、C语言代码:bool checkRecord(char * s){ int c = 0; for(int i = 0;s[i] != '\0';i++){ if(s[i] == 'L' &amp;&amp; s[i+1] == 'L' &amp;&amp; s[i+2] == 'L') return false; if(s[i] == 'A') c++; if(c >= 2) return false; } return true; } 解释： 遍历字符串，如果有超过3个连续的’L’或者有超过2个’A’，则返回false，否则返回true。 知识点回顾： 无。 2、Java代码:class Solution { public boolean checkRecord(String s) { return s.indexOf("A") == s.lastIndexOf("A") &amp;&amp; !s.contains("LLL"); } } 解释： 如果数组中没有超过2个’A’或者不存在”LLL”,则返回true，否则返回false。 知识点回顾：1、indexOf() 方法有以下四种形式： public int indexOf(int ch): 返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。 public int indexOf(int ch, int fromIndex): 返回从 fromIndex 位置开始查找指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。 int indexOf(String str): 返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。 int indexOf(String str, int fromIndex): 返回从 fromIndex 位置开始查找指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。 2、lastIndexOf() 方法有以下四种形式： public int lastIndexOf(int ch): 返回指定字符在此字符串中最后一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。 public int lastIndexOf(int ch, int fromIndex): 返返回指定字符在此字符串中最后一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。 public int lastIndexOf(String str): 返回指定字符在此字符串中最后一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。 public int lastIndexOf(String str, int fromIndex): 返回指定字符在此字符串中最后一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。 3、contains()函数用于确定一个字符串是否包含指定的子串。 3、Python代码：class Solution: def checkRecord(self, s: str) -> bool: return s.count('A')&lt;=1 and 'LLL' not in s 解释： 类似于Java的求解思路。 知识点回顾： 无。 4、JavaScript代码：/** * @param {string} s * @return {boolean} */ var checkRecord = function (s) { return s.indexOf('A') === s.lastIndexOf('A') &amp;&amp; s.indexOf('LLL') === -1 }; 解释： 类似于Java的求解思路。 知识点回顾：1、lastIndexOf() 方法可返回一个指定的字符串值最后出现的位置，如果指定第二个参数 start，则在一个字符串中的指定位置从后向前搜索。注意： 该方法将从后向前检索字符串，但返回是从起始位置 (0) 开始计算子字符串最后出现的位置。 看它是否含有字符串。开始检索的位置在字符串的 start 处或字符串的结尾（没有指定 start 时）。如果没有找到匹配字符串则返回 -1 。注意：lastIndexOf() 方法是区分大小写的！语法：string.lastIndexOf(searchvalue,start)searchvalue：必需。规定需检索的字符串值。start：可选的整数参数。规定在字符串中开始检索的位置。它的合法取值是 0 到 stringObject.length - 1。如省略该参数，则将从字符串的最后一个字符处开始检索。返回值：查找的字符串最后出现的位置，如果没有找到匹配字符串则返回 -1。2、indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。如果没有找到匹配的字符串则返回 -1。注意： indexOf() 方法区分大小写。语法：string.indexOf(searchvalue,start)searchvalue：必需。规定需检索的字符串值。start：可选的整数参数。规定在字符串中开始检索的位置。它的合法取值是 0 到 string Object.length - 1。如省略该参数，则将从字符串的首字符开始检索。返回值：查找指定字符串第一次出现的位置，如果没找到匹配的字符串则返回 -1。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之922]]></title>
    <url>%2F2019%2F08%2F28%2Fleetcode-shua-ti-ji-lu-zhi-922%2F</url>
    <content type="text"><![CDATA[922、按奇偶排序数组 II给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。你可以返回任何满足上述条件的数组作为答案。示例 1： 输入：[4,2,5,7] 输出：[4,5,2,7] 解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。 提示: 2 &lt;= A.length &lt;= 20000 A.length % 2 == 0 0 &lt;= A[i] &lt;= 1000 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/sort-array-by-parity-ii/ 1、C语言代码:/** * Note: The returned array must be malloced, assume caller calls free(). */ int* sortArrayByParityII(int* A, int ASize, int* returnSize){ int* s = malloc(sizeof(int)*ASize); int k = 0,j = 1; for(int i = 0;i &lt; ASize;i++){ if(A[i]%2 == 0){ s[k] = A[i]; k += 2; } else{ s[j] = A[i]; j += 2; } } *returnSize = ASize; return s; } 解释： 循环数组A，如果A[i]为偶数，则放入数组s中下标为偶数的位置，A[i]为奇数时，则放入数组s中下标为偶数的部分。 知识点回顾： 无。 2、Java代码:class Solution { public int[] sortArrayByParityII(int[] A) { int j = 1; for (int i = 0; i &lt; A.length; i += 2) if (A[i] % 2 == 1) { while (A[j] % 2 == 1) j += 2; // Swap A[i] and A[j] int tmp = A[i]; A[i] = A[j]; A[j] = tmp; } return A; } } 解释： 不需要额外开辟空间，在这个问题里面，一旦所有偶数都放在了正确的位置上，那么所有奇数也一定都在正确的位子上。所以只需要关注 A[0], A[2], A[4], … 都正确就可以了。将数组分成两个部分，分别是偶数部分 even = A[0], A[2], A[4], … 和奇数部分 odd = A[1], A[3], A[5], …。定义两个指针 i 和 j, 每次循环都需要保证偶数部分中下标 i 之前的位置全是偶数，奇数部分中下标 j 之前的位置全是奇数。让偶数部分下标 i 之前的所有数都是偶数。为了实现这个目标，把奇数部分作为暂存区，不断增加指向奇数部分的指针，直到找到一个偶数，然后交换指针 i，j 所指的数。 知识点回顾： 无。 3、Python代码：class Solution: def sortArrayByParityII(self, A: List[int]) -> List[int]: ia = [i for i in A if not(i % 2)] ja = [i for i in A if i % 2] return [i for n in zip(ia, ja) for i in n] 解释： 利用zip函数遍历。 知识点回顾：1、zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象，这样做的好处是节约了不少的内存。我们可以使用 list() 转换来输出列表。如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。语法：zip([iterable, …])iterabl：一个或多个迭代器。返回值：返回一个对象。 4、JavaScript代码：/** * @param {number[]} A * @return {number[]} */ var sortArrayByParityII = function(A) { let arr = []; let odd = 1; let even = 0; for (let i = 0; i &lt; A.length; i++) { if (A[i]%2 === 0) { arr[even] = A[i]; even = even +2; }else { arr[odd] = A[i]; odd = odd+2; } } return arr; }; 解释： 类似于C语言的求解思路。 知识点回顾： 无。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之561]]></title>
    <url>%2F2019%2F08%2F28%2Fleetcode-shua-ti-ji-lu-zhi-561%2F</url>
    <content type="text"><![CDATA[561、数组拆分 I&emsp;&emsp;给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。示例 1： 输入: [1,4,3,2] 输出: 4 解释: n 等于 2, 最大总和为 4 = min(1, 2) + min(3, 4). 提示: n 是正整数,范围在 [1, 10000]. 数组中的元素范围在 [-10000, 10000]. 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/array-partition-i/ 1、C语言代码:int arrayPairSum(int* nums, int numsSize) { int n[20001] = { 0 }, i, j, sum; for (i = 0; i &lt; numsSize; i++) //建立值、键哈希表，即基数排序 n[nums[i] + 10000]++; //保证下标为正数 for (i = j = sum = 0; i &lt; 20001; ) //将下标为 0、2、4 ... 的相加 if (n[i]){ //判断是否存在该数，若存在则判断是否偶数下标 if (j % 2 == 0) sum += i - 10000; //偶数下标，累加 j++; //计数 n[i]--; //该值减 1 } else i++; //不存在，跳过该值 return sum; } 解释： 排序，然后将下标为 0、2、4 … 个数相加即可。 由于是纯数字，并且限定了数字范围，所以可使用基数排序达到 O(n) 复杂度。 数字范围 [-10000, 10000]，所以可创建 n[20001]，对每个元素加 10000 使其变为正数。 知识点回顾： 本题若使用冒泡排序会超时，关于排序算法，将在数据结构篇中详细说明。 2、Java代码:class Solution { public int arrayPairSum(int[] nums) { Arrays.sort(nums); int sum = 0; for (int i = 0; i &lt; nums.length; i += 2) { sum += nums[i]; } return sum; } } 解释： 为了理解这种方法，让我们从不同的角度来看待问题。我们需要形成数组元​​素的配对，使得这种配对中最小的总和最大。因此，我们可以查看选择配对中最小值的操作，比如 (a,b)(a,b)(a,b) 可能会产生的最大损失 a−ba-ba−b (如果 a&gt;ba &gt; ba&gt;b)。如果这类配对产生的总损失最小化，那么总金额现在将达到最大值。只有当为配对选择的数字比数组的其他元素更接近彼此时，才有可能将每个配对中的损失最小化。考虑到这一点，我们可以对给定数组的元素进行排序，并直接按排序顺序形成元素的配对。这将导致元素的配对，它们之间的差异最小，从而导致所需总和的最大化。 知识点回顾： 无。 3、Python代码：class Solution: def arrayPairSum(self, nums: List[int]) -> int: return sum(sorted(nums)[::2]) 解释： 排序 + 切片，再求和。 知识点回顾： 无。 4、JavaScript代码：/** * @param {number[]} nums * @return {number} */ var arrayPairSum = function(nums) { //nums升序，取偶数位之和 nums.sort((a,b)=>a-b); let res = 0; for(let i = 0;i &lt; nums.length;i += 2){ res += nums[i]; } return res; }; 解释： 先进行排序，再对数组中下标为偶数的元素求和。 知识点回顾： 无。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>数组</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之905]]></title>
    <url>%2F2019%2F08%2F28%2Fleetcode-shua-ti-ji-lu-zhi-905%2F</url>
    <content type="text"><![CDATA[905、按奇偶排序数组&emsp;&emsp;给定一个非负整数数组 A，返回一个数组，在该数组中， A 的所有偶数元素之后跟着所有奇数元素。&emsp;&emsp;你可以返回满足此条件的任何数组作为答案。示例 1： 输入：[3,1,2,4] 输出：[2,4,3,1] 输出 [4,2,3,1]，[2,4,1,3] 和 [4,2,1,3] 也会被接受。 提示： 1 &lt;= A.length &lt;= 5000 0 &lt;= A[i] &lt;= 5000 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/sort-array-by-parity/ 1、C语言代码:/** * Note: The returned array must be malloced, assume caller calls free(). */ int* sortArrayByParity(int* A, int ASize, int* returnSize){ int* ans = malloc(sizeof(int)*ASize); int t = 0; for (int i = 0; i &lt; ASize; ++i){ if (A[i] % 2 == 0) ans[t++] = A[i]; } for (int i = 0; i &lt; ASize; ++i){ if (A[i] % 2 == 1) ans[t++] = A[i]; } *returnSize = ASize; return ans; } 解释： 两遍扫描，第一遍输出偶数，第二遍输出奇数。 知识点回顾： 无。 2、Java代码:class Solution { public int[] sortArrayByParity(int[] A) { int i = 0, j = A.length - 1; while (i &lt; j) { if (A[i] % 2 > A[j] % 2) { int tmp = A[i]; A[i] = A[j]; A[j] = tmp; } if (A[i] % 2 == 0) i++; if (A[j] % 2 == 1) j--; } return A; } } 解释： 原地算法，如果希望原地排序，可以使用快排，一个经典的算法。&emsp;&emsp;维护两个指针 i 和 j，循环保证每刻小于 i 的变量都是偶数（也就是 A[k] % 2 == 0 当 k &lt; i），所有大于 j 的都是奇数。所以， 4 种情况针对 (A[i] % 2, A[j] % 2)： 如果是 (0, 1)，那么万事大吉 i++ 并且 j–。 如果是 (1, 0)，那么交换两个元素，然后继续。 如果是 (0, 0)，那么说明 i 位置是正确的，只能 i++。 如果是 (1, 1)，那么说明 j 位置是正确的，只能 j–。 &emsp;&emsp;通过这 4 种情况，循环不变量得以维护，并且 j-i 不断变小。最终就可以得到奇偶有序的数组。 知识点回顾： 快排的思想，将在数据结构篇中单独描述。 3、Python代码：class Solution: def sortArrayByParity(self, A: List[int]) -> List[int]: i = 0; for j in range(len(A)): if A[j] % 2 == 0: A[i], A[j] = A[j], A[i] i += 1 return A 解释： 、双指针同向遍历，初始状态都指在数组左端，后面指针不断加一，遇到偶数就交换到前面去，再把前面指针加一，指导后面指针遍历完数组结束。 知识点回顾： 无。 4、JavaScript代码：/** * @param {number[]} A * @return {number[]} */ var sortArrayByParity = function(A) { var B = [] for (var i = 0; i &lt; A.length; i++) { if (A[i] % 2 === 0) { B.unshift(A[i]) } else { B.push(A[i]) } } return B }; 解释： 一次循环，如果为偶数就添加到头部，如果为奇数就添加到尾部。 知识点回顾：1、unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。注意： 该方法将改变数组的数目。提示: 将新项添加到数组末尾，请使用 push() 方法。语法：array.unshift(item1,item2, …, itemX)item1,item2, …, itemX：必需。向数组起始位置添加一个或者多个元素。返回值：Number数组新长度。2、push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。注意： 新元素将添加在数组的末尾。注意： 此方法改变数组的长度。提示： 在数组起始位置添加元素请使用 unshift() 方法。语法：array.push(item1, item2, …, itemX)item1,item2, …, itemX：必需。要添加到数组的元素。返回值：Number数组新长度。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>数组</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之977]]></title>
    <url>%2F2019%2F08%2F27%2Fleetcode-shua-ti-ji-lu-zhi-977%2F</url>
    <content type="text"><![CDATA[977、有序数组的平方&emsp;&emsp;给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。示例 1： 输入：[-4,-1,0,3,10] 输出：[0,1,9,16,100] 示例 2： 输入：[-7,-3,2,3,11] 输出：[4,9,9,49,121] 提示： 1 &lt;= A.length &lt;= 10000 -10000 &lt;= A[i] &lt;= 10000 A 已按非递减顺序排序。 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/squares-of-a-sorted-array/ 1、C语言代码:/** * Note: The returned array must be malloced, assume caller calls free(). */ int* sortedSquares(int* A, int ASize, int* returnSize) { int i = 0,j = ASize - 1; int k = ASize - 1; int *b = (int *)malloc(sizeof(int)*ASize); while(i &lt;= j){ if(abs(A[i]) > abs(A[j])){ b[k] = A[i] * A[i]; k--; i++; } else{ b[k] = A[j] * A[j]; k--; j--; } } *returnSize = ASize; return b; } 解释： 方法：双指针。因为数组 A 已经排好序了， 所以可以说数组中的负数已经按照平方值降序排好了，数组中的非负数已经按照平方值升序排好了。举一个例子，若给定数组为 [-3, -2, -1, 4, 5, 6]，数组中负数部分 [-3, -2, -1] 的平方为 [9, 4, 1]，数组中非负部分 [4, 5, 6] 的平方为 [16, 25, 36]。我们的策略就是从前向后遍历数组中的非负数部分，并且反向遍历数组中的负数部分。我们可以使用两个指针分别读取数组的非负部分与负数部分 —— 指针 i 反向读取负数部分，指针 j 正向读取非负数部分。那么，现在我们就在使用两个指针分别读取两个递增的数组了（按元素的平方排序）。接下来，我们可以使用双指针的技巧合并这两个数组。 知识点回顾： 双指针技巧的使用。 2、Java代码:class Solution { public static int[] sortedSquares(int[] A) { for(int i = 0; i &lt; A.length; i++){ A[i] *= A[i]; } Arrays.sort(A); return A; } } 解释： 先计算数组A中各个数字的平方，再排序返回。 知识点回顾： 无。 3、Python代码：class Solution: def sortedSquares(self, A: List[int]) -> List[int]: return sorted([i * i for i in A]) 解释： 类似于Java的求解思路。 知识点回顾：1、sorted() 函数对所有可迭代的对象进行排序操作。sort 与 sorted 区别： sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。 list 的 sort 方法返回的是对已经存在的列表进行操作，无返回值，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。 语法：sorted(iterable, cmp=None, key=None, reverse=False)iterable：可迭代对象。cmp：比较的函数，这个具有两个参数，参数的值都是从可迭代对象中取出，此函数必须遵守的规则为，大于则返回1，小于则返回-1，等于则返回0。key：主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。reverse：排序规则，reverse = True 降序 ， reverse = False 升序（默认）。返回值：返回重新排序的列表。 4、JavaScript代码：/** * @param {number[]} A * @return {number[]} */ var sortedSquares = function(A) { return A.map(item=>(Math.pow(item,2))).sort((a,b)=>a-b); }; 解释： 类似于Java的求解思路。 知识点回顾：1、map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。map() 方法按照原始数组元素顺序依次处理元素。注意： map() 不会对空数组进行检测。注意： map() 不会改变原始数组。语法：array.map(function(currentValue,index,arr), thisValue)function(currentValue, index,arr)：必须。函数，数组中的每个元素都会执行这个函数currentValue：必须。当前元素的值。index：可选。当前元素的索引值。arr：可选。当前元素属于的数组对象。thisValue：可选。对象作为该执行回调时使用，传递给函数，用作 “this” 的值。如果省略了 thisValue，或者传入 null、undefined，那么回调函数的 this 为全局对象。返回值：返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。2、sort() 方法用于对数组的元素进行排序。语法：arrayObject.sort(sortby)sortby：可选。规定排序顺序。必须是函数。返回值：对数组的引用。请注意，数组在原数组上进行排序，不生成副本。3、=&gt;是es6语法中的arrow function例如： (x) =&gt; x + 6 等价于 function(x){ return x + 6; };]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>数组</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之728]]></title>
    <url>%2F2019%2F08%2F26%2Fleetcode-shua-ti-ji-lu-zhi-728%2F</url>
    <content type="text"><![CDATA[728、自除数自除数是指可以被它包含的每一位数除尽的数。例如，128 是一个自除数，因为 128 % 1 == 0，128 % 2 == 0，128 % 8 == 0。还有，自除数不允许包含 0 。给定上边界和下边界数字，输出一个列表，列表的元素是边界（含边界）内所有的自除数。示例 1： 输入： 上边界left = 1, 下边界right = 22 输出： [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22] 注意： 每个输入参数的边界满足 1 &lt;= left &lt;= right &lt;= 10000。 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/self-dividing-numbers/ 1、C语言代码:/** * Note: The returned array must be malloced, assume caller calls free(). */ int* selfDividingNumbers(int left, int right, int* returnSize) { int *result = (int *)malloc(sizeof(int) * (right - left + 1)); *returnSize = 0; for (int v, d; left &lt;= right; ++left) { v = left; while (v > 0) { d = v % 10; if (d == 0 || left % d != 0) { break; } v /= 10; } if (v == 0) { result[*returnSize] = left; *returnSize += 1; } } return result; } 解释： 遍历从left到right到每个数。 如果这个数符合要求，把它添加到输出列表中。 如何判断是否符合要求？ 设置一个临时变量等于这个原数。 每次让临时变量对10取余，即是临时变量的末尾，比如128对10取余的结果是8。 判断原数对这个余数是否能整除，不能就直接break了，进入下一个数。 临时变量对自己整除10，比如128整除10就是12了，这样再下个循环中取余就是2 注意两点。 取余数后要先判断是否等于0，因为没有办法对0求余数。注意or 运算先算左边再算右边，顺序不能错咯。 设置一个临时变量是否等于0的判断，来鉴别while是被break了还是正常结束。 知识点回顾：C语言动态分配内存：&emsp;&emsp;(1) malloc（）、calloc（）&emsp;&emsp;&emsp;&emsp;分配新的内存区域。&emsp;&emsp;(2) realloc（）&emsp;&emsp;&emsp;&emsp;调整已分配的内存区域。&emsp;&emsp;(3) free（）&emsp;&emsp;&emsp;&emsp;释放已分配的内存区域。 2、Java代码:class Solution { public List&lt;Integer> selfDividingNumbers(int left, int right) { List&lt;Integer> ans = new ArrayList&lt;Integer>(); for(int i = left; i &lt;= right; i++){ boolean isMatch = true; int k = i; while(k != 0){ int val = k % 10; if(val == 0 || i % val != 0){ isMatch = false; break; } k /= 10; } if(isMatch){ ans.add(i); } } return ans; } } 解释： 类似于C语言的求解思路。 知识点回顾： 无。 3、Python代码：class Solution: def selfDividingNumbers(self, left: int, right: int) -> List[int]: ans = [] for num in range(left,right + 1): copy = num while copy > 0: div, copy = copy % 10, copy // 10 if div == 0 or num % div != 0: break else: ans.append(num) # while … else 在循环条件为 false 时执行 else 语句块 return ans 解释： 类似于C语言的求解思路。 知识点回顾：1、range() 函数可创建一个整数列表，一般用在 for 循环中。语法：range(start, stop[, step])start：计数从 start 开始。默认是从 0 开始。例如range（5）等价于range（0， 5）;stop：计数到 stop 结束，但不包括 stop。例如：range（0， 5） 是[0, 1, 2, 3, 4]没有5step：步长，默认为1。例如：range（0， 5） 等价于 range(0, 5, 1)3 4、JavaScript代码：/** * @param {number} left * @param {number} right * @return {number[]} */ var selfDividingNumbers = function(left, right) { var res = []; var str, num, flag; for(;left &lt;= right;left++){ flag = true str = String(left); for(var i = 0;i &lt; str.length;i++){ num = Number(str[i]); if(num === 0 || left % num !== 0){ flag = false; break; } } if(flag){ res.push(left); } } return res; }; 解释： 类似于C语言的求解思路。 知识点回顾：1、push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。注意： 新元素将添加在数组的末尾。注意： 此方法改变数组的长度。提示： 在数组起始位置添加元素请使用 unshift() 方法。语法：array.push(item1, item2, …, itemX)item1, item2, …, itemX：必需。要添加到数组的元素。返回值：Number，数组新长度。2、JavaScript中==和===的区别：双等号==： （1）如果两个值类型相同，再进行三个等号(===)的比较。 （2）如果两个值类型不同，也有可能相等，需根据以下规则进行类型转换在比较： &emsp;&emsp; 1）如果一个是null，一个是undefined，那么相等。 &emsp;&emsp; 2）如果一个是字符串，一个是数值，把字符串转换成数值之后再进行比较。三等号===: （1）如果类型不同，就一定不相等 （2）如果两个都是数值，并且是同一个值，那么相等；如果其中至少一个是NaN，那么不相等。（判断一个值是否是NaN，只能使用isNaN( ) 来判断） （3）如果两个都是字符串，每个位置的字符都一样，那么相等，否则不相等。 （4）如果两个值都是true，或是false，那么相等。 （5）如果两个值都引用同一个对象或是函数，那么相等，否则不相等。 （6）如果两个值都是null，或是undefined，那么相等。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之27]]></title>
    <url>%2F2019%2F08%2F26%2Fleetcode-shua-ti-ji-lu-zhi-27%2F</url>
    <content type="text"><![CDATA[27、移除元素&emsp;&emsp;给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。&emsp;&emsp;不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。&emsp;&emsp;元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。示例 1： 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2： 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。 注意这五个元素可为任意顺序。 你不需要考虑数组中超出新长度后面的元素。 说明：为什么返回数值是整数，但输出的答案是数组呢?请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。你可以想象内部操作如下： // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝 int len = removeElement(nums, val); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i &lt; len; i++) { print(nums[i]); } 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/remove-element/ 1、C语言代码:int removeElement(int* nums, int numsSize, int val){ int len = 0; for (int j = 0; j &lt; numsSize; ++j) { if(nums[j] != val){ nums[len++] = nums[j]; } } return len; } 解释： 方法：双指针。既然问题要求我们就地删除给定值的所有元素，我们就必须用 O(1)的额外空间来处理它。如何解决？我们可以保留两个指针len和 j，其中 len 是慢指针，j 是快指针。当 nums[j]与给定的值相等时，递增 j 以跳过该元素。只要nums[j]≠val，我们就复制 nums[j] 到 nums[len] 并同时递增两个索引。重复这一过程，直到 j 到达数组的末尾，该数组的新长度为 len。该解法与删除排序数组中的重复项的解法十分相似。 知识点回顾： 无。 2、Java代码:class Solution { public int removeElement(int[] nums, int val) { int i = 0; int n = nums.length; while (i &lt; n) { if (nums[i] == val) { nums[i] = nums[n - 1]; // reduce array size by one n--; } else { i++; } } return n; } } 解释： 方法二：双指针 —— 当要删除的元素很少时。现在考虑数组包含很少的要删除的元素的情况。例如，num=[1，2，3，5，4]，Val=4num=[1，2，3，5，4]，Val=4num=[1，2，3，5，4]，Val=4。之前的算法会对前四个元素做不必要的复制操作。另一个例子是 num=[4，1，2，3，5]，Val=4num=[4，1，2，3，5]，Val=4num=[4，1，2，3，5]，Val=4。似乎没有必要将 [1，2，3，5][1，2，3，5][1，2，3，5] 这几个元素左移一步，因为问题描述中提到元素的顺序可以更改。当我们遇到 nums[i]=valnums[i] = valnums[i]=val 时，我们可以将当前元素与最后一个元素进行交换，并释放最后一个元素。这实际上使数组的大小减少了 1。请注意，被交换的最后一个元素可能是您想要移除的值。但是不要担心，在下一次迭代中，我们仍然会检查这个元素。 知识点回顾：1、length() 方法用于返回字符串的长度。长度等于字符串中 16 位 Unicode 代码单元的数量。语法：public int length()返回值：返回字符串长度。 3、Python代码：class Solution: def removeElement(self, nums: List[int], val: int) -> int: for i in range(nums.count(val)): nums.remove(val) return len(nums) 解释： 统计val在nums数组里出现的次数，在nums中移除等于val的数，再返回nums数组的长度。 知识点回顾：1、range() 函数可创建一个整数列表，一般用在 for 循环中。语法：range(start, stop[, step])start：计数从 start 开始。默认是从 0 开始。例如range（5）等价于range（0， 5）;stop：计数到 stop 结束，但不包括 stop。例如：range（0， 5） 是[0, 1, 2, 3, 4]没有5step：步长，默认为1。例如：range（0， 5） 等价于 range(0, 5, 1)32、 count() 方法用于统计字符串里某个字符出现的次数。可选参数为在字符串搜索的开始与结束位置。语法：str.count(sub, start= 0,end=len(string))sub：搜索的子字符串。start：字符串开始搜索的位置。默认为第一个字符,第一个字符索引值为0。end：字符串中结束搜索的位置。字符中第一个字符的索引为 0。默认为字符串的最后一个位置。返回值：该方法返回子字符串在字符串中出现的次数。3、remove() 函数用于移除列表中某个值的第一个匹配项。语法：list.remove(obj)obj：列表中要移除的对象。返回值：该方法没有返回值但是会移除列表中的某个值的第一个匹配项。4、len() 方法返回对象（字符、列表、元组等）长度或项目个数。语法：len( s )s：对象。返回值：返回对象长度。 4、JavaScript代码：/** * @param {number[]} nums * @param {number} val * @return {number} */ var removeElement = function(nums, val) { for(let i = 0; i&lt; nums.length; i++) { if(nums[i] === val) { nums.splice(i, 1); i--; } } return nums.length; }; 解释： 原地移除，改变原数组，选择splice()，如果数组里碰到相同的val，就splice掉这一项，此时数组项数就少了一个，i要往后退回一个，即i–， 结束。 知识点回顾：1、splice() 方法用于添加或删除数组中的元素。注意：这种方法会改变原始数组。语法：array.splice(index,howmany,item1,…..,itemX)index：必需。规定从何处添加/删除元素。该参数是开始插入和（或）删除的数组元素的下标，必须是数字。howmany：可选。规定应该删除多少元素。必须是数字，但可以是 “0”。如果未规定此参数，则删除从 index 开始到原数组结尾的所有元素。item1, …, itemX：可选。要添加到数组的新元素返回值：如果仅删除一个元素，则返回一个元素的数组。 如果未删除任何元素，则返回空数组。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之509]]></title>
    <url>%2F2019%2F08%2F25%2Fleetcode-shua-ti-ji-lu-zhi-509%2F</url>
    <content type="text"><![CDATA[509、斐波那契数斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：&emsp;&emsp;F(0) = 0, F(1) = 1&emsp;&emsp;F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.给定 N，计算 F(N)。示例 1: 输入：2 输出：1 解释：F(2) = F(1) + F(0) = 1 + 0 = 1. 示例 2: 输入：3 输出：2 解释：F(3) = F(2) + F(1) = 1 + 1 = 2. 示例 3: 输入：4 输出：3 解释：F(4) = F(3) + F(2) = 2 + 1 = 3. 提示： 0 ≤ N ≤ 30 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/fibonacci-number/ 1、C语言代码：int fib(int N){ if(N &lt;= 0) return 0; if(N == 1 || N == 2) return 1; return fib(N - 2) + fib(N - 1); } 解释： 递归求解。 知识点回顾： 斐波那契数的递归解法。 2、Java代码：//解法一 class Solution { public int fib(int N) { int i = 0; int sum = 0, num = 1; while(i++ &lt; N) { sum += num; num = sum - num; } return sum; } } //解法二 class Solution { public int fib(int N) { int curr = 0, next = 1; while(N-- > 0) { next = next + curr; curr = next - curr; } return curr; } } 解释： 解法一：使用了动态规划。解法二：使用动态规划消除重复计算，可使时间复杂度优化至O(n)。可用数组保存计算结果，则空间复杂度为O(n)。此处进一步简化，只使用两个变量保存结果，因此空间复杂度为O(1)。 知识点回顾：1、-&gt;是lambda表达式,就是匿名函数。2、动态规划的相关知识，，将在数据结构篇中单独描述。 3、Python代码：class Solution: def fib(self, N: int) -> int: memo = [0,1] for i in range (2,N+1): memo.append(memo[i-1] + memo[i-2]) return memo[N] 解释： 使用了动态规划。 知识点回顾：1、动态规划的相关知识，，将在数据结构篇中单独描述。2、range() 函数可创建一个整数列表，一般用在 for 循环中。语法：range(start, stop[, step])start：计数从 start 开始。默认是从 0 开始。例如range（5）等价于range（0， 5）;stop：计数到 stop 结束，但不包括 stop。例如：range（0， 5） 是[0, 1, 2, 3, 4]没有5step：步长，默认为1。例如：range（0， 5） 等价于 range(0, 5, 1)33、append() 方法用于在列表末尾添加新的对象。语法：list.append(obj)obj：添加到列表末尾的对象。返回值：该方法无返回值，但是会修改原来的列表。 4、JavaScript代码：/** * @param {number} N * @return {number} */ var fib = function(N) { let [a, b] = [0, 1] let i = 0 while (i &lt; N) { [a, b] = [b, b + a] i++ } return a }; 解释： JavaScript迭代。 知识点回顾： ES6数组的解构赋值的运用。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之344]]></title>
    <url>%2F2019%2F08%2F25%2Fleetcode-shua-ti-ji-lu-zhi-344%2F</url>
    <content type="text"><![CDATA[344、反转字符串&emsp;&emsp;编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。&emsp;&emsp;不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。&emsp;&emsp;你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。示例 1: 输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;] 输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;] 示例 2: 输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;] 输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;] 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/reverse-string/ 1、C语言代码：void reverseString(char* s, int sSize){ int from = 0 ,to = sSize - 1 ; char type; while(from &lt; to){ type = s[from]; s[from++] = s[to]; s[to--] = type; } } 解释： 头尾双指针，from由前向后，to由后向前，使用O(1)的额外空间使字符串头尾两个元素调换，从而实现字符串反转。 知识点回顾： 字符串反转的相关知识。 2、Java代码：class Solution { public void reverseString(char[] s) { int j = s.length-1; for(int i=0;i&lt;s.length/2;i++){ char tmp = s[i]; s[i] = s[j]; s[j] = tmp; j--; } } } 解释： 循环数组，首尾交换。 知识点回顾： 字符串反转的相关知识。 3、Python代码：#解法一 class Solution: def reverseString(self, s: List[str]) -> None: """ Do not return anything, modify s in-place instead. """ s[0::]=s[::-1] #解法二 class Solution: def reverseString(self, s: List[str]) -> None: """ Do not return anything, modify s in-place instead. """ s.reverse() 解释： 解法一：利用切片的知识之间反转。解法二：利用函数之间反转。 知识点回顾： 字符串反转的相关知识。1、reverse() 函数用于反向列表中元素。语法：list.reverse()返回值：该方法没有返回值，但是会对列表的元素进行反向排序。 4、JavaScript代码：/** * @param {character[]} s * @return {void} Do not return anything, modify s in-place instead. */ var reverseString = function(s) { let right = 0 let left = s.length - 1 while(right &lt; left) { [s[right], s[left]] = [s[left], s[right]] right++ left-- } }; 解释： js双指针，对撞指针。 知识点回顾： 字符串反转的相关知识，ES6数组的解构赋值的运用。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之35]]></title>
    <url>%2F2019%2F08%2F25%2Fleetcode-shua-ti-ji-lu-zhi-35%2F</url>
    <content type="text"><![CDATA[35、搜索插入位置&emsp;&emsp;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。&emsp;&emsp;你可以假设数组中无重复元素。示例 1: 输入: [1,3,5,6], 5 输出: 2 示例 2: 输入: [1,3,5,6], 2 输出: 1 示例 3: 输入: [1,3,5,6], 7 输出: 4 示例 4: 输入: [1,3,5,6], 0 输出: 0 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/search-insert-position/ 1、C语言代码：int searchInsert(int* nums, int numsSize, int target){ for(int i=0;i&lt;numsSize;i++){ if(nums[i] >= target) return i; } return numsSize; } 解释： 遍历有序数组，当第一个大于等于target的值出现时，返回当前的下标，否则，就代表target大于数组中全部数字，则返回numsSize。 知识点回顾： 无，最简单的暴力求法。 2、Java代码：class Solution { public int searchInsert(int[] nums, int target) { int left = 0, right = nums.length - 1; while(left &lt;= right) { int mid = (left + right) / 2; if(nums[mid] == target) { return mid; } else if(nums[mid] &lt; target) { left = mid + 1; } else { right = mid - 1; } } return left; } } 解释： 标签：二分查找。 如果该题目暴力解决的话需要 O(n)的时间复杂度，但是如果二分的话则可以降低到 O(logn)的时间复杂度。 整体思路和普通的二分查找几乎没有区别，先设定左侧下标 left 和右侧下标 right，再计算中间下标 mid。 每次根据 nums[mid] 和 target 之间的大小进行判断，相等则直接返回下标，nums[mid] &lt; target 则 left 右移，nums[mid] &gt; target 则 right 左移。 查找结束如果没有相等值则返回 left，该值为插入位置。 时间复杂度：O(logn) 知识点回顾： 二分查找的相关知识，之后在数据结构篇中也会有更详细的描述。 3、Python代码：class Solution: def searchInsert(self, nums: List[int], target: int) -> int: nums.append(target) nums.sort() return nums.index(target) 解释：1、将 target 插入到数组中，同时，做一下排序。2、这样，得到一个一定包含 target 的有序的新数组。3、target 目前所在的位置，即是 target 对应元素的 原始位置 或者 插入位置。 知识点回顾：1、append() 方法用于在列表末尾添加新的对象。语法：list.append(obj)obj：添加到列表末尾的对象。返回值：该方法无返回值，但是会修改原来的列表。2、sort() 函数用于对原列表进行排序，如果指定参数，则使用比较函数指定的比较函数。语法：list.sort( key=None, reverse=False)key：主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。reverse：排序规则，reverse = True 降序， reverse = False 升序（默认）。返回值：该方法没有返回值，但是会对列表的对象进行排序。3、index() 方法检测字符串中是否包含子字符串 str ，如果指定 beg（开始） 和 end（结束） 范围，则检查是否包含在指定范围内，该方法与 python find()方法一样，只不过如果str不在 string中会报一个异常。语法：str.index(str, beg=0, end=len(string))str：指定检索的字符串beg：开始索引，默认为0。end：结束索引，默认为字符串的长度。返回值：如果包含子字符串返回开始的索引值，否则抛出异常。 4、JavaScript代码：/** * @param {number[]} nums * @param {number} target * @return {number} */ var searchInsert = function (nums, target) { var left = 0; var right = nums.length - 1; if (target > nums[right]) return right + 1; while (left &lt; right) { var index = parseInt((left + right) >>> 1);//取左中位数 if (nums[index] &lt; target) left = index + 1; //中位数小于目标值，削去区间左侧 else right = index; //中位数大于等于目标值，削去区间右侧 } return left; }; 解释： 初始区间的设置 left = 0 right = nums.length-1。 当target大于nums中最大的元素时，返回的索引值在区间外，为nums.length，因此提前进行判断。 while循环的条件为left &lt; right，当left = right时跳出循环。 中位数选取左中位数使用无符号右移left + right &gt;&gt;&gt; 1防止溢出 （也可选取右中位数，但if-else也需要同时修改） 在选取了左中位数的基础上，if-else需要保证左边界收缩，因此先写left = index+1，再根据+1填写if括号中的条件为nums[index]&lt;target，再补全else即可。 由于只有在left = right时才能跳出循环，所以返回leftright均可。 知识点回顾：1、二分查找的相关知识，之后在数据结构篇中也会有更详细的描述。2、parseInt() 函数可解析一个字符串，并返回一个整数。语法：parseInt(string, radix)string：必需。要被解析的字符串。radix：可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。返回值：返回解析后的数字。说明：当参数 radix 的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。3、&gt;&gt;&gt;无符号移位：该操作符会将第一个操作数向右移动指定的位数。向右被移出的位被丢弃，左侧用0填充。因为符号位变成了 0，所以结果总是非负的。（即便右移 0 个比特，结果也是非负的。）]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之7]]></title>
    <url>%2F2019%2F08%2F25%2Fleetcode-shua-ti-ji-lu-zhi-7%2F</url>
    <content type="text"><![CDATA[7、整数反转&emsp;&emsp;给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。示例 1： 输入: 123 输出: 321 示例 2： 输入: -123 输出: -321 示例 3： 输入: 120 输出: 21 注意： 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/reverse-integer/ 1、C语言代码:int reverse(int x){ long res = 0; while(x != 0){ res = res * 10 + x % 10; if (res > INT_MAX || res &lt; INT_MIN) { return 0; } x /= 10; } return res; } 解释： 直接倒序翻转x，判断res是否溢出，如果溢出直接返回0。 知识点回顾： INT_MAX和INT_MIN表示C语言中int的上下限,在标准头文件limits.h中定义。 2、Java代码:class Solution { public int reverse(int x) { int rev = 0; while (x != 0) { int pop = x % 10; x /= 10; if (rev > Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 &amp;&amp; pop > 7)) return 0; if (rev &lt; Integer.MIN_VALUE/10 || (rev == Integer.MIN_VALUE / 10 &amp;&amp; pop &lt; -8)) return 0; rev = rev * 10 + pop; } return rev; } } 解释： 方法：弹出和推入数字 &amp; 溢出前进行检查，我们可以一次构建反转整数的一位数字。在这样做的时候，我们可以预先检查向原整数附加另一位数字是否会导致溢出。反转整数的方法可以与反转字符串进行类比。我们想重复“弹出” xxx 的最后一位数字，并将它“推入”到 rev的后面。最后，rev 将与 xxx 相反。要在没有辅助堆栈 / 数组的帮助下 “弹出” 和 “推入” 数字，我们可以使用数学方法。但是，这种方法很危险，因为当 temp=rev*10+pop 时会导致溢出。幸运的是，事先检查这个语句是否会导致溢出很容易。为了便于解释，我们假设 rev 是正数。如果 temp=rev*10+pop 导致溢出，那么一定有 rev≥INTMAX​/10。如果 rev&gt;INTMAX/10​，那么 temp=rev*10+pop一定会溢出。如果 rev==INTMAX/10，那么只要 pop&gt;7，temp=rev*10+pop 就会溢出。当 rev为负时可以应用类似的逻辑。 知识点回顾： 判断溢出的方法。 3、Python代码：class Solution: def reverse(self, x: int) -> int: flag = -1 if x &lt; 0 else 1 res = flag * int(str(abs(x))[::-1]) return res if (-2**31)&lt;=res&lt;=(2**31-1) else 0 解释： 利用切片进行反转，加上了对溢出的判断。 知识点回顾： 数字类型之间的转化，切片的使用。判断溢出的方法。数值对象不可能之间用切片。 4、JavaScript代码：/** * @param {number} x * @return {number} */ var reverse = function (x) { var re = 0; while (parseInt(x / 10)) { re = 10 * re + x - 10 * parseInt(x / 10); x = parseInt(x / 10); } if (re > 214748364 || re &lt; -214748364) return 0; if ((re == 214748364 &amp;&amp; x > 7) || (re == 214748364 &amp;&amp; x &lt; -8)) return 0; re = 10 * re + x; return re }; 解释： 类似于Java求解的思路。 知识点回顾：1、parseInt() 函数可解析一个字符串，并返回一个整数。语法：parseInt(string, radix)string：必需。要被解析的字符串。radix：可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。返回值：返回解析后的数字。说明：当参数 radix 的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。&emsp;&emsp;举例，如果 string 以 “0x” 开头，parseInt() 会把 string 的其余部分解析为十六进制的整数。如果 string 以 0 开头，那么 ECMAScript v3 允许 parseInt() 的一个实现把其后的字符解析为八进制或十六进制的数字。如果 string 以 1 ~ 9 的数字开头，parseInt() 将把它解析为十进制的整数。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之9]]></title>
    <url>%2F2019%2F08%2F25%2Fleetcode-shua-ti-ji-lu-zhi-9%2F</url>
    <content type="text"><![CDATA[9、回文数&emsp;&emsp;判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。示例 1： 输入: 121 输出: true 示例 2： 输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3： 输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶：&emsp;&emsp;你能不将整数转为字符串来解决这个问题吗？难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/palindrome-number/ 1、C语言代码：//解法一 bool isPalindrome(int x){ int a,i = 0; int s[10]; if(x &lt; 0){ return false; } while(x > 0){ a = x % 10; s[i++] = a; x /= 10; } for(int j = 0;j &lt; i;j++){ if(s[j] != s[--i]){ return false; } } return true; } //解法二 bool isPalindrome(int x){ int y = x ; //用y记住原先值 long res=0; //直接定义为long型，用于存储翻转后的数据，因为int型取值范围内倒转可能会溢出 while(x > 0){ res = res*10 + x%10; x = x/10; } if(res == y) return true; else return false; } 解释： 解法一：当x小于0直接返回false，当x大于0时，先将整数各位分别存放数组中，再从首尾遍历，进行判断。解法二：将x倒序，和原来的值进行比较，相等为true。否则为false。 知识点回顾： 回文的知识，数值的倒序求法。 2、Java代码：class Solution { public boolean isPalindrome(int x) { // 特殊情况： // 如上所述，当 x &lt; 0 时，x 不是回文数。 // 同样地，如果数字的最后一位是 0，为了使该数字为回文， // 则其第一位数字也应该是 0 // 只有 0 满足这一属性 if(x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) { return false; } int revertedNumber = 0; while(x > revertedNumber) { revertedNumber = revertedNumber * 10 + x % 10; x /= 10; } // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。 // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123， // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。 return x == revertedNumber || x == revertedNumber/10; } } 解释： 映入脑海的第一个想法是将数字转换为字符串，并检查字符串是否为回文。但是，这需要额外的非常量空间来创建问题描述中所不允许的字符串。第二个想法是将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。但是，如果反转后的数字大于 int.MAX，我们将遇到整数溢出问题。按照第二个想法，为了避免数字反转可能导致的溢出问题，为什么不考虑只反转 int数字的一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。例如，输入 1221，我们可以将数字 “1221” 的后半部分从 “21” 反转为 “12”，并将其与前半部分 “12” 进行比较，因为二者相同，我们得知数字 1221 是回文。让我们看看如何将这个想法转化为一个算法。&emsp;&emsp;首先，我们应该处理一些临界情况。所有负数都不可能是回文，例如：-123 不是回文，因为 - 不等于 3。所以我们可以对所有负数返回 false。现在，让我们来考虑如何反转后半部分的数字。对于数字 1221，如果执行 1221 % 10，我们将得到最后一位数字 1，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 1221 中移除，1221 / 10 = 122，再求出上一步结果除以 10 的余数，122 % 10 = 2，就可以得到倒数第二位数字。如果我们把最后一位数字乘以 10，再加上倒数第二位数字，1 * 10 + 2 = 12，就得到了我们想要的反转后的数字。如果继续这个过程，我们将得到更多位数的反转数字。现在的问题是，我们如何知道反转数字的位数已经达到原始数字位数的一半？我们将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于反转后的数字时，就意味着我们已经处理了一半位数的数字。 知识点回顾： 回文的知识，数值的倒序求法。 3、Python代码：class Solution: def isPalindrome(self, x: int) -> bool: return str(x) == str(x)[::-1] 解释： 利用切片，直接进行比较。 知识点回顾： 回文的知识。 4、JavaScript代码：/** * @param {number} x * @return {boolean} */ var isPalindrome = function(x) { let x1 = String(x) let arr = x1.split('') if (arr.reverse().join('') == x1) return true return false }; 解释： 先把原来的数值x转化成字符串，再分割成字符串数组，翻转之后进行对比，相等就返回true，否则返回false。 知识点回顾：1、split() 方法用于把一个字符串分割成字符串数组。语法：stringObject.split(separator,howmany)separator：必需。字符串或正则表达式，从该参数指定的地方分割 stringObject。howmany：可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。返回值：一个字符串数组。该数组是通过在 separator 指定的边界处将字符串 stringObject 分割成子串创建的。返回的数组中的字串不包括 separator 自身。但是，如果 separator 是包含子表达式的正则表达式，那么返回的数组中包括与这些子表达式匹配的字串（但不包括与整个正则表达式匹配的文本）。注释：如果把空字符串 (“”) 用作 separator，那么 stringObject 中的每个字符之间都会被分割。注释：String.split() 执行的操作与 Array.join 执行的操作是相反的。2、join() 方法用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。语法： arrayObject.join(separator)separator：可选。指定要使用的分隔符。如果省略该参数，则使用逗号作为分隔符。返回值：返回一个字符串。该字符串是通过把 arrayObject 的每个元素转换为字符串，然后把这些字符串连接起来，在两个元素之间插入 separator 字符串而生成的。3、reverse() 方法用于颠倒数组中元素的顺序。语法：arrayObject.reverse()注释：该方法会改变原来的数组，而不会创建新的数组。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之1]]></title>
    <url>%2F2019%2F08%2F24%2Fleetcode-shua-ti-ji-lu-zhi-1%2F</url>
    <content type="text"><![CDATA[1、两数之和&emsp;&emsp;给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。&emsp;&emsp;你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。示例一： 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/two-sum/ 1、C语言代码：/** * Note: The returned array must be malloced, assume caller calls free(). */ int* twoSum(int* nums, int numsSize, int target, int * returnSize){ *returnSize = 2; int i,j; static int a[2] = {0}; for(i = 0; i &lt; numsSize; i++){ for(j = i + 1; j &lt; numsSize; j++){ if(nums[i] + nums[j] == target){ a[0] = i; a[1] = j; return a; } } } return NULL; } 解释： 暴力解法，双重循环，当有2个数的和为target时，返回，否则返回NULL。 知识点回顾：1、在我们日常使用过程中，static通常有两个作用: 修饰变量&emsp;&emsp;静态全局变量：全局变量前加static修饰，该变量就成为了静态全局变量。我们知道，全部变量在整个工程都可以被访问（一个文件中定义，其它文件使用的时候添加extern关键字声明 ），而在添加了static关键字之后，这个变量就只能在本文件内被访问了。因此，在这里，static的作用就是限定作用域。&emsp;&emsp;静态局部变量：局不变量添加了static修饰之后，该变量就成为了静态局部变量。我们知道局部变量在离开了被定义的函数后，就会被销毁，而当使用static修饰之后，它的作用域就一直到整个程序结束。因此，在这里static的作用就是限定生命周期。 修饰函数&emsp;&emsp;修饰函数则该函数成为静态函数，函数的作用域仅限于本文件，而不能被其它文件调用。 2、Java代码：class Solution { public int[] twoSum(int[] nums, int target) { Map&lt;Integer, Integer> map = new HashMap&lt;>(); for(int i = 0; i&lt; nums.length; i++) { if(map.containsKey(target - nums[i])) { return new int[] {map.get(target-nums[i]),i}; } map.put(nums[i], i); } throw new IllegalArgumentException("No two sum solution"); } } 解释： 标签：哈希映射。 这道题本身如果通过暴力遍历的话也是很容易解决的，时间复杂度在 O(n2)。 由于哈希查找的时间复杂度为 O(1)，所以可以利用哈希容器 map 降低时间复杂度。 遍历数组 nums，i 为当前下标，每个值都判断map中是否存在 target-nums[i] 的 key 值。 如果存在则找到了两个值，如果不存在则将当前的 (nums[i],i) 存入 map 中，继续遍历直到找到为止。 如果最终都没有结果则抛出异常。 时间复杂度：O(n)。 知识点回顾：1、 containsKey()方法用于检查特定键是否被映射到HashMap。它将key元素作为参数，如果该元素在map中映射，则返回True。语法：Hash_Map.containsKey（key_element）参数：该方法只接受一个参数key_element，该参数引用应在map内检查其映射的键。返回值：如果检测到密钥的存在，则该方法返回布尔值true，否则返回false。 3、Python代码：class Solution: def twoSum(self, nums: List[int], target: int) -> List[int]: hashmap = {} for index, num in enumerate(nums): result = target - num if result in hashmap: return [hashmap[result], index] hashmap[num] = index return None 解释： 类似于Java求解的思路。 知识点回顾：1、enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。语法：enumerate(sequence, [start=0])sequence：一个序列、迭代器或其他支持迭代对象。start：下标起始位置。返回值：返回 enumerate(枚举) 对象。 4、JavaScript代码：/** * @param {number[]} nums * @param {number} target * @return {number[]} */ var twoSum = function(nums, target) { let map = new Map() for (let i = 0; i &lt; nums.length; i++) { if(map.has(target - nums[i])){ return [map.get(target - nums[i]), i] } map.set(nums[i], i) } }; 解释： 类似于Java的求解思路。 知识点回顾： 哈希表的相关内容，将在数据结构篇中单独描述。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之709]]></title>
    <url>%2F2019%2F08%2F23%2Fleetcode-shua-ti-ji-lu-zhi-709%2F</url>
    <content type="text"><![CDATA[709、转换成小写字母&emsp;&emsp;实现函数 ToLowerCase()，该函数接收一个字符串参数 str，并将该字符串中的大写字母转换成小写字母，之后返回新的字符串。示例 1: 输入: &quot;Hello&quot; 输出: &quot;hello&quot; 示例 2: 输入: &quot;here&quot; 输出: &quot;here&quot; 示例三： 输入: &quot;LOVELY&quot; 输出: &quot;lovely&quot; 难度：简单 &emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/to-lower-case/ 1、C语言代码： char * toLowerCase(char * str){ for(int i = 0;str[i] != '\0';i++){ if(str[i] >= 'A' &amp;&amp; str[i] &lt;= 'Z') str[i] += 32; } return str; } 解释： 遍历字符串数组str，如果存在大写字符就转换成小写字符，并且返回。 知识点回顾： ASCII 码小写字母比大写字母大32。 2、Java代码：class Solution { public String toLowerCase(String str) { return str.toLowerCase(); } } 解释： 直接将str中全部大写字母转化成小写的。 知识点回顾：1、toLowerCase() 方法用于将大写字符转换为小写。2、toUpperCase() 方法将字符串从小写转为大写。 3、Python代码：class Solution: def toLowerCase(self, str: str) -> str: return str.lower() 解释： 直接将str中全部大写字母转化成小写的。 知识点回顾：1、upper()：把所有字符中的小写字母转换成大写字母。2、lower()：把所有字符中的大写字母转换成小写字母。3、capitalize()：把第一个字母转化为大写字母，其余小写。4、title()：把每个单词的第一个字母转化为大写，其余小写 。 4、JavaScript代码：/** * @param {string} str * @return {string} */ var toLowerCase = function(str) { return str.toLowerCase(); }; 解释： 直接将str中全部大写字母转化成小写的。 知识点回顾：1、toLocaleUpperCase：将字符串中所有的字母字符都将被转换为大写的，同时适应宿主环境的当前区域设置。2、toUpperCase：将字符串中的所有字母都被转化为大写字母。3、toLocaleLowerCase：将字符串所有的字母字符都被转换为小写，同时考虑到宿主环境的当前区域设置。4、toLowerCase：将字符串中的字母被转换为小写字母。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之237]]></title>
    <url>%2F2019%2F08%2F23%2Fleetcode-shua-ti-ji-lu-zhi-237%2F</url>
    <content type="text"><![CDATA[237、删除链表中的节点请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。现有一个链表 – head = [4,5,1,9]，它可以表示为:示例 1: 输入: head = [4,5,1,9], node = 5 输出: [4,1,9] 解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9. 示例 2: 输入: head = [4,5,1,9], node = 1 输出: [4,5,9] 解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9. 说明: 链表至少包含两个节点。 链表中所有节点的值都是唯一的。 给定的节点为非末尾节点并且一定是链表中的一个有效节点。 不要从你的函数中返回任何结果。 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/delete-node-in-a-linked-list/ 1、C语言代码：/** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ void deleteNode(struct ListNode* node) { node->val = node->next->val; node->next = node->next->next; } 解释： node下一个结点的值赋值给node，并且node下一个节点的指针域赋值给node1的指针域。 知识点回顾： 链表的相关知识，将在数据结构篇中单独描述。 2、Java代码：/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public void deleteNode(ListNode node) { node.val = node.next.val; node.next = node.next.next; } } 解释： node下一个结点的值赋值给node，并且node下一个节点的指针域赋值给node1的指针域。 知识点回顾： 链表的相关知识，将在数据结构篇中单独描述。 3、Python代码：# Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def deleteNode(self, node): """ :type node: ListNode :rtype: void Do not return anything, modify node in-place instead. """ node.val = node.next.val node.next = node.next.next 解释： node下一个结点的值赋值给node，并且node下一个节点的指针域赋值给node1的指针域。 知识点回顾： 链表的相关知识，将在数据结构篇中单独描述。 4、JavaScript代码：/** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} node * @return {void} Do not return anything, modify node in-place instead. */ var deleteNode = function(node) { node.val = node.next.val; node.next = node.next.next; }; 解释： node下一个结点的值赋值给node，并且node下一个节点的指针域赋值给node1的指针域。 知识点回顾： 链表的相关知识，将在数据结构篇中单独描述。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之1108]]></title>
    <url>%2F2019%2F08%2F23%2Fleetcode-shua-ti-ji-lu-zhi-1108%2F</url>
    <content type="text"><![CDATA[1108、IP 地址无效化给你一个有效的 IPv4 地址 address，返回这个 IP 地址的无效化版本。所谓无效化 IP 地址，其实就是用 “[.]” 代替了每个 “.”。示例 1: 输入：address = &quot;1.1.1.1&quot; 输出：&quot;1[.]1[.]1[.]1&quot; 示例 2: 输入：address = &quot;255.100.50.0&quot; 输出：&quot;255[.]100[.]50[.]0&quot; 提示： 给出的 address 是一个有效的 IPv4 地址 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/defanging-an-ip-address/ 1、C语言代码：char * defangIPaddr(char * address){ char *rec = malloc(23 * sizeof(char)); int j = 0; for(int i = 0; address[i] != '\0'; i++) { if (address[i] != '.') rec[j++] = address[i]; else { rec[j++] = '['; rec[j++] = '.'; rec[j++] = ']'; } } rec[j] = '\0'; return rec; } 解释： 首先分配23个char大小的内存给rec数组，遍历address字符串数组，不等于’.’时将address原字符加入rec数组中，等于’.’时，将[.]加入数组，最后返回字符串。 知识点回顾：‘’代表字符，””是代码一个字符串。’\0’是一个字符串的结束符。 2、Java代码：class Solution { public String defangIPaddr(String address) { String a = "" + address.charAt(0); for(int i = 1;i &lt; address.length();i++){ if(address.charAt(i) == '.'){ a +="[.]"; }else a += address.charAt(i); } return a; } } 解释： 创建一个新的字符串a，先address中首字符加入到a中，遍历address，不等于’.’时将address原字符加入a数组中，等于’.’时，将[.]加入数组，最后返回字符串。 知识点回顾：1、charAt() 方法用于返回指定索引处的字符。索引范围为从 0 到 length() - 1。语法：public char charAt(int index)index：字符的索引。返回值：返回指定索引处的字符。 3、Python代码：class Solution: def defangIPaddr(self, address: str) -> str: return address.replace('.','[.]') 解释： 在address中找到’.’用’[.]’代替。 知识点回顾：1、replace() 方法把字符串中的 old（旧字符串） 替换成 new(新字符串)，如果指定第三个参数max，则替换不超过 max 次。语法：str.replace(old, new[, max])old：将被替换的子字符串。new：新字符串，用于替换old子字符串。max：可选字符串, 替换不超过 max 次。返回值：返回字符串中的 old（旧字符串） 替换成 new(新字符串)后生成的新字符串，如果指定第三个参数max，则替换不超过 max 次。 4、JavaScript代码： /** * @param {string} address * @return {string} */ var defangIPaddr = function(address) { address=address.split(""); for(let i = 0;i &lt; address.length;i++){ if(address[i] === '.'){ address[i] = '[.]';//写"[.]"也对 } } return address.join(""); }; 解释：先把字符串address分割成字符串数组，遍历address，等于’.’时用’[.]’代替’.’，最后把字符串数组中的元素放回address中，返回。 知识点回顾：1、split() 方法用于把一个字符串分割成字符串数组。语法：stringObject.split(separator,howmany)separator：必需。字符串或正则表达式，从该参数指定的地方分割 stringObject。howmany：可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。返回值：一个字符串数组。该数组是通过在 separator 指定的边界处将字符串 stringObject 分割成子串创建的。返回的数组中的字串不包括 separator 自身。但是，如果 separator 是包含子表达式的正则表达式，那么返回的数组中包括与这些子表达式匹配的字串（但不包括与整个正则表达式匹配的文本）。注释：如果把空字符串 (“”) 用作 separator，那么 stringObject 中的每个字符之间都会被分割。注释：String.split() 执行的操作与 Array.join 执行的操作是相反的。2、join() 方法用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。语法： arrayObject.join(separator)separator：可选。指定要使用的分隔符。如果省略该参数，则使用逗号作为分隔符。返回值：返回一个字符串。该字符串是通过把 arrayObject 的每个元素转换为字符串，然后把这些字符串连接起来，在两个元素之间插入 separator 字符串而生成的。3、JavaScript中==和===的区别：双等号==： （1）如果两个值类型相同，再进行三个等号(===)的比较。 （2）如果两个值类型不同，也有可能相等，需根据以下规则进行类型转换在比较： 1）如果一个是null，一个是undefined，那么相等。 2）如果一个是字符串，一个是数值，把字符串转换成数值之后再进行比较。三等号===: （1）如果类型不同，就一定不相等 （2）如果两个都是数值，并且是同一个值，那么相等；如果其中至少一个是NaN，那么不相等。（判断一个值是否是NaN，只能使用isNaN( ) 来判断） （3）如果两个都是字符串，每个位置的字符都一样，那么相等，否则不相等。 （4）如果两个值都是true，或是false，那么相等。 （5）如果两个值都引用同一个对象或是函数，那么相等，否则不相等。 （6）如果两个值都是null，或是undefined，那么相等。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之771]]></title>
    <url>%2F2019%2F08%2F22%2Fleetcode-shua-ti-ji-lu-zhi-771%2F</url>
    <content type="text"><![CDATA[771、宝石与石头 &emsp;&emsp;给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。 &emsp;&emsp;J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。 示例 1: 输入: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot; 输出: 3 示例 2: 输入: J = &quot;z&quot;, S = &quot;ZZ&quot; 输出: 0 注意: S 和 J 最多含有50个字母。 J 中的字符不重复。 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/jewels-and-stones/ 1、C语言代码：int numJewelsInStones(char * J, char * S){ int count = 0; for(int i = 0;J[i] != '\0';i++){ for(int j = 0;S[j] != '\0';j++){ if(J[i] == S[j]) count += 1; } } return count; } 解释：先定义并且初始化一个变量count用于存放结果，再遍历2个字符串数组，如果字符串数组J中的字符出现在了字符串数组S中，则count加1，最后输出结果。 知识点回顾：C语言中字符串处理以’\0’为结束符。 2、Java代码：class Solution { public static int numJewelsInStones(String J, String S) { int count = 0; for (int i = 0; i &lt; S.toCharArray().length; i++) { if(J.indexOf(S.toCharArray()[i]) != -1){ count ++; } } return count; } } 解释：先定义并且初始化一个变量count用于存放结果，先字符串S转化为字符串数组并且遍历，一旦S中的字符有在J中出现count就加1，最后输出结果。 知识点回顾：1、toCharArray() 方法将字符串转换为字符数组。 参数：无。返回值：字符数组。2、length() 方法用于返回字符串的长度。参数：无。返回值：返回字符串长度。3、indexOf() 方法有以下四种形式： public int indexOf(int ch): 返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。 public int indexOf(int ch, int fromIndex): 返回从 fromIndex 位置开始查找指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。 int indexOf(String str): 返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。 int indexOf(String str, int fromIndex): 返回从 fromIndex 位置开始查找指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。 3、Python代码：class Solution: def numJewelsInStones(self, J: str, S: str) -> int: return sum([S.count(x) for x in J]) 解释：创建一个临时变量x，x在S出现并且在J中出现，求和返回。 知识点回顾：1、count() 方法用于统计字符串里某个字符出现的次数。可选参数为在字符串搜索的开始与结束位置。语法：str.count(sub, start= 0,end=len(string))sub：搜索的子字符串start：字符串开始搜索的位置。默认为第一个字符,第一个字符索引值为0。end：字符串中结束搜索的位置。字符中第一个字符的索引为 0。默认为字符串的最后一个位置。返回值：该方法返回子字符串在字符串中出现的次数。2、sum() 方法对系列进行求和计算。语法：sum(iterable[, start])iterable：可迭代对象，如：列表、元组、集合。start：指定相加的参数，如果没有设置这个值，默认为0。返回值：返回计算结果。 4、JavaScript代码：/** * @param {string} J * @param {string} S * @return {number} */ var numJewelsInStones = function(J, S) { var count = 0; for(var i = 0;i &lt; S.length;i++){ if(J.indexOf(S[i]) != -1){ count += 1; } } return count; }; 解释：先定义并且初始化一个变量count用于存放结果，遍历字符串数组S，一旦S中的字符有在J中出现count就加1，最后输出结果。 知识点回顾：1、length() 方法用于返回字符串的长度。参数：无。返回值：返回字符串长度。2、indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。语法：stringObject.indexOf(searchvalue,fromindex)searchvalue： 必需。规定需检索的字符串值。fromindex：可选的整数参数。规定在字符串中开始检索的位置。它的合法取值是 0 到 stringObject.length - 1。如省略该参数，则将从字符串的首字符开始检索。说明：该方法将从头到尾地检索字符串 stringObject，看它是否含有子串 searchvalue。开始检索的位置在字符串的 fromindex 处或字符串的开头（没有指定 fromindex 时）。如果找到一个 searchvalue，则返回 searchvalue 的第一次出现的位置。stringObject 中的字符位置是从 0 开始的。 注释：indexOf() 方法对大小写敏感！ 注释：如果要检索的字符串值没有出现，则该方法返回 -1。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端基础（一）]]></title>
    <url>%2F2019%2F08%2F19%2Fqian-duan-ji-chu-yi%2F</url>
    <content type="text"><![CDATA[一、HTML:• HTML（Hypertext Markup Language） 超文本标记语言。• 它负责网页的三个要素之中的结构。• HTML使用标签的的形式来标识网页中的不 同组成部分。• 所谓超文本指的是超链接，使用超链接可 以让我们从一个页面跳转到另一个页面。 先上一个最基本的HTML框架结构： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;网页标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;网页正文&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 做如下解释：&emsp;&emsp;1、html根标签，一个页面中有且只有一个根标签，网页中的所有内容都应该写在html根标签中。&emsp;&emsp;2、head标签，该标签中的内容，不会在网页中直接显示，它用来帮助浏览器解析页面的。&emsp;&emsp;3、title网页的标题标签，默认会显示在浏览器的标题栏中， 搜索引擎在检索页面时，会首先检索title标签中的内容，它是网页中对于搜索引擎来说最重要的内容，会影响到网页在搜索引擎中的排名。&emsp;&emsp;4、body标签用来设置网页的主体内容，网页中所有可见的内容，都应该在body中编写。注：更多标签说明参考W3Cschool。 二、CSS&emsp;&emsp;HTML较为简单，主要就是标签的使用，在这里我不想做过多的描述，大家可以在W3Cschool中学习到，接下来描述CSS部分。• 层叠样式表 (Cascading Style Sheets)• css可以用来为网页创建样式表，通过样式 表可以对网页进行装饰。• 所谓层叠，可以将整个网页想象成是一层 一层的结构，层次高的将会覆盖层次低的。 • 而css就可以分别为网页的各个层次设置样式。 HTML引用CSS的四种方式:1、行内样式 &lt;p style=&quot;color: #FF0000;&quot;&gt;行内样式&lt;/p&gt; • 可以直接将样式写到标签内部的style属性中，这种样式不用填写选择器，直接编写声明即可。• 这种方式编写简单，定位准确。但是由于直接将css代码写到了html标签的内部，导致结构与表现耦合，同时导致样式不能够复用，所以这种方式我们不使用。2、内部样式表 &lt;style&gt; p{color:red; font-size: 30px;} &lt;/style&gt; • 可以直接将样式写到&lt;style&gt;标签中。• 这样使css独立于html代码，而且可以同时为多个元素设置样式，这是我们使用的比较多的一种方式。• 但是这种方式，样式只能在一个页面中使用，不能在多个页面中重复使用。3、外部样式表 &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot;&gt; • 可以将所有的样式保存到一个外部的css文件中，然后通过&lt;link&gt;标签将样式表引入到文件中。• 这种方式将样式表放入到了页面的外部，可以在多个页面中引入，同时浏览器加载文件时可以使用缓存，这是我们开发中使用的最多的方式。4、导入样式表 &lt;style&gt; @import url(a.css); &lt;/style&gt; • 导入样式和链接样式比较相似，采用@import样式导入CSS样式表，在HTML初始化时，会被导入到HTML或者CSS文件中，成为文件的一部分，类似第二种内嵌样式。 最后提供几个学习前端知识优秀的网站。1、菜鸟教程：提供了编程的基础技术教程。2、W3Cschool：w3cschool是一个专业的web前端开发及编程入门学习平台。3、馨客栈：内容超级丰富。4、实验楼：可以自己动手操作。5、自强学堂：致力于提供优质的IT技术教程。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机专业书籍推荐]]></title>
    <url>%2F2019%2F08%2F16%2Fshu-ji-tui-jian%2F</url>
    <content type="text"><![CDATA[计算机专业书籍推荐Linux 编程：《鸟哥Linux私房菜》最权威的Linux书籍之一《Linux 系统编程》对常用 API 讲述最详细的一本书《UNIX 环境高级编程》经典《The Linux Programming Interface》与上本书配套《程序员的自我修养》别被名字误导，极好的一本深度基础书。《深入理解 Linux 内核》可以翻翻，对提升细节理解有好处。《UNIX 网络编程》经典《TCP/IP协议详细》第一卷 –经典的无以复加《TCP/IP 高级编程》好书 C/C++:《C Primer Plus》经典书《C++ Primer》C++最权威的书籍之一《C 程序设计语言》入门书《Lnux C 编程一站式学习》Linux 下开发的入门书《C 语言核心技术》参考手册《彻底搞定 C 指针》最好的指针入门书《C++ 编程思想》经典《高质量程序设计指南——C/C++语言》经典《C 专家编程》《C 和指针》《C 陷阱与缺陷》 Golang:《Learing Go》简单《The Go Programming Language》比较详细《The way to Go》提升 Javascript:《Javascript, A Beginner’s Guide》《Object-Oriented Javascript》 Python:《Python编程：从入门到实践》对新手非常友好《Python Pocket Reference》适合经常翻翻《Expert Python Programming》某些地方很有启发 java：《JAVA编程思想》划时代的java巨作《Java核心技术 卷1 基础知识》全面掌握基础知识《Java核心技术 卷2 高级特性》对Java高级特性有更深入的理解《Java并发编程艺术》并发编程的艺术《深入理解Java虚拟机》Java虚拟机的相关知识 算法：《算法笔记》适合新手《挑战程序设计竞赛》《算法竞赛入门经典》《算法导论》最权威的算法书之一《计算机程序设计艺术》算法届的宏伟著作 其他:《深入理解计算机系统》经典，必读《计算机组成与设计》可以翻翻《汇编语言》王爽 最好的汇编入门书《数据结构》C 语言版 经典《Java 数据结构和算法》更易阅读《Debug Hacks 中文版》GDB 入门书《设计模式——可复用面向对象软件的基础》经典《MongoDB, The Definitive Guide》《算法导论》第三版 –经典书籍《数据库系统实现》（第2版）–想自己开发数据库可以看看《精通正则表达式（第3版）》 –深入了解和使用正则《代码简洁之道》《代码大全》《编程之美》]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题记录之1295]]></title>
    <url>%2F2019%2F01%2F07%2Fleetcode-shua-ti-ji-lu-zhi-1295%2F</url>
    <content type="text"><![CDATA[1295、统计位数为偶数的数字&emsp;&emsp;给你一个整数数组 nums，请你返回其中位数为偶数的数字的个数。示例 1： 输入：nums = [12,345,2,6,7896] 输出：2 解释： 12 是 2 位数字（位数为偶数） 345 是 3 位数字（位数为奇数） 2 是 1 位数字（位数为奇数） 6 是 1 位数字 位数为奇数） 7896 是 4 位数字（位数为偶数） 因此只有 12 和 7896 是位数为偶数的数字 示例 2： 输入：nums = [555,901,482,1771] 输出：1 解释： 只有 1771 是位数为偶数的数字。 提示： 1 &lt;= nums.length &lt;= 500 1 &lt;= nums[i] &lt;= 10^5 难度：简单&emsp;&emsp;&emsp;&emsp;题目地址：https://leetcode-cn.com/problems/find-numbers-with-even-number-of-digits/ 1、C语言代码：int findNumbers(int* nums, int numsSize){ int c = 0; for(int i =0 ;i &lt; numsSize;i++){ if((nums[i] >= 10 &amp;&amp; nums[i] &lt;= 99)||(nums[i] >= 1000 &amp;&amp; nums[i] &lt;= 9999)) c++; } return c; } 解释： 已知范围为1 &lt;= nums[i] &lt;= 10^5，所以只有两个区间内的数为偶数位10 ~ 99以及1000 ~ 9999。 知识点回顾： 无。 2、Java代码：class Solution { public int findNumbers(int[] nums) { int count = 0; for (int i = 0; i &lt; nums.length; i++) { int N = nums[i]; //记录除10的次数 int countTen = 0; while (N != 0) { N/=10; countTen++; } //如果除10的次数是偶数次，则该数为偶数位数 if (countTen % 2 == 0) { count++; } } return count; } } 解释： 数字循环除10，统计等于0的时候除10的次数，偶数次则该数为偶数位。 知识点回顾： 无。 3、Python代码：class Solution: def findNumbers(self, nums: List[int]) -> int: return sum(1 for num in nums if len(str(num)) % 2 == 0) 解释： 一种简单的方法是使用语言内置的整数转字符串函数，将 x 转换为字符串后，判断其长度是否为偶数即可。 知识点回顾： 无。 4、JavaScript代码：/** * @param {number[]} nums * @return {number} */ var findNumbers = function(nums) { return nums.filter(i=> i.toString().length %2 == 0).length }; 解释： 类似于Python的求解思路。 知识点回顾： 无。]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode简单题</tag>
        <tag>数学</tag>
      </tags>
  </entry>
</search>
